// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CosmosBlock cosmos block
//
// swagger:model CosmosBlock
type CosmosBlock struct {

	// block
	Block *CosmosBlockBlock `json:"block,omitempty"`

	// block id
	BlockID *CosmosBlockBlockID `json:"block_id,omitempty"`

	// sdk block
	SdkBlock *CosmosBlockSdkBlock `json:"sdk_block,omitempty"`
}

// Validate validates this cosmos block
func (m *CosmosBlock) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlock(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBlockID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSdkBlock(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlock) validateBlock(formats strfmt.Registry) error {
	if swag.IsZero(m.Block) { // not required
		return nil
	}

	if m.Block != nil {
		if err := m.Block.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlock) validateBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockID) { // not required
		return nil
	}

	if m.BlockID != nil {
		if err := m.BlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block_id")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlock) validateSdkBlock(formats strfmt.Registry) error {
	if swag.IsZero(m.SdkBlock) { // not required
		return nil
	}

	if m.SdkBlock != nil {
		if err := m.SdkBlock.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sdk_block")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sdk_block")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos block based on the context it is used
func (m *CosmosBlock) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBlock(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSdkBlock(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlock) contextValidateBlock(ctx context.Context, formats strfmt.Registry) error {

	if m.Block != nil {

		if swag.IsZero(m.Block) { // not required
			return nil
		}

		if err := m.Block.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlock) contextValidateBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.BlockID != nil {

		if swag.IsZero(m.BlockID) { // not required
			return nil
		}

		if err := m.BlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block_id")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlock) contextValidateSdkBlock(ctx context.Context, formats strfmt.Registry) error {

	if m.SdkBlock != nil {

		if swag.IsZero(m.SdkBlock) { // not required
			return nil
		}

		if err := m.SdkBlock.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sdk_block")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sdk_block")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlock) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlock) UnmarshalBinary(b []byte) error {
	var res CosmosBlock
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlock cosmos block block
//
// swagger:model CosmosBlockBlock
type CosmosBlockBlock struct {

	// data
	Data *CosmosBlockBlockData `json:"data,omitempty"`

	// evidence
	Evidence *CosmosBlockBlockEvidence `json:"evidence,omitempty"`

	// header
	Header *CosmosBlockBlockHeader `json:"header,omitempty"`

	// last commit
	LastCommit *CosmosBlockBlockLastCommit `json:"last_commit,omitempty"`
}

// Validate validates this cosmos block block
func (m *CosmosBlockBlock) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateData(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEvidence(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHeader(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastCommit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlock) validateData(formats strfmt.Registry) error {
	if swag.IsZero(m.Data) { // not required
		return nil
	}

	if m.Data != nil {
		if err := m.Data.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "data")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "data")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockBlock) validateEvidence(formats strfmt.Registry) error {
	if swag.IsZero(m.Evidence) { // not required
		return nil
	}

	if m.Evidence != nil {
		if err := m.Evidence.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "evidence")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "evidence")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockBlock) validateHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.Header) { // not required
		return nil
	}

	if m.Header != nil {
		if err := m.Header.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "header")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockBlock) validateLastCommit(formats strfmt.Registry) error {
	if swag.IsZero(m.LastCommit) { // not required
		return nil
	}

	if m.LastCommit != nil {
		if err := m.LastCommit.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "last_commit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "last_commit")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos block block based on the context it is used
func (m *CosmosBlockBlock) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateData(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEvidence(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLastCommit(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlock) contextValidateData(ctx context.Context, formats strfmt.Registry) error {

	if m.Data != nil {

		if swag.IsZero(m.Data) { // not required
			return nil
		}

		if err := m.Data.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "data")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "data")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockBlock) contextValidateEvidence(ctx context.Context, formats strfmt.Registry) error {

	if m.Evidence != nil {

		if swag.IsZero(m.Evidence) { // not required
			return nil
		}

		if err := m.Evidence.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "evidence")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "evidence")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockBlock) contextValidateHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.Header != nil {

		if swag.IsZero(m.Header) { // not required
			return nil
		}

		if err := m.Header.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "header")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockBlock) contextValidateLastCommit(ctx context.Context, formats strfmt.Registry) error {

	if m.LastCommit != nil {

		if swag.IsZero(m.LastCommit) { // not required
			return nil
		}

		if err := m.LastCommit.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "last_commit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "last_commit")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlock) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlock) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlock
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockData cosmos block block data
//
// swagger:model CosmosBlockBlockData
type CosmosBlockBlockData struct {

	// txs
	Txs []strfmt.Base64 `json:"txs"`
}

// Validate validates this cosmos block block data
func (m *CosmosBlockBlockData) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos block block data based on context it is used
func (m *CosmosBlockBlockData) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockData) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockData) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockData
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockEvidence cosmos block block evidence
//
// swagger:model CosmosBlockBlockEvidence
type CosmosBlockBlockEvidence struct {

	// evidence
	Evidence []*CosmosBlockBlockEvidenceEvidenceItems0 `json:"evidence"`
}

// Validate validates this cosmos block block evidence
func (m *CosmosBlockBlockEvidence) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEvidence(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockEvidence) validateEvidence(formats strfmt.Registry) error {
	if swag.IsZero(m.Evidence) { // not required
		return nil
	}

	for i := 0; i < len(m.Evidence); i++ {
		if swag.IsZero(m.Evidence[i]) { // not required
			continue
		}

		if m.Evidence[i] != nil {
			if err := m.Evidence[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("block" + "." + "evidence" + "." + "evidence" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("block" + "." + "evidence" + "." + "evidence" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this cosmos block block evidence based on the context it is used
func (m *CosmosBlockBlockEvidence) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateEvidence(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockEvidence) contextValidateEvidence(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Evidence); i++ {

		if m.Evidence[i] != nil {

			if swag.IsZero(m.Evidence[i]) { // not required
				return nil
			}

			if err := m.Evidence[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("block" + "." + "evidence" + "." + "evidence" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("block" + "." + "evidence" + "." + "evidence" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockEvidence) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockEvidence) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockEvidence
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockEvidenceEvidenceItems0 cosmos block block evidence evidence items0
//
// swagger:model CosmosBlockBlockEvidenceEvidenceItems0
type CosmosBlockBlockEvidenceEvidenceItems0 struct {

	// duplicate vote evidence
	DuplicateVoteEvidence *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidence `json:"duplicate_vote_evidence,omitempty"`

	// light client attack evidence
	LightClientAttackEvidence *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidence `json:"light_client_attack_evidence,omitempty"`
}

// Validate validates this cosmos block block evidence evidence items0
func (m *CosmosBlockBlockEvidenceEvidenceItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDuplicateVoteEvidence(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLightClientAttackEvidence(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0) validateDuplicateVoteEvidence(formats strfmt.Registry) error {
	if swag.IsZero(m.DuplicateVoteEvidence) { // not required
		return nil
	}

	if m.DuplicateVoteEvidence != nil {
		if err := m.DuplicateVoteEvidence.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0) validateLightClientAttackEvidence(formats strfmt.Registry) error {
	if swag.IsZero(m.LightClientAttackEvidence) { // not required
		return nil
	}

	if m.LightClientAttackEvidence != nil {
		if err := m.LightClientAttackEvidence.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos block block evidence evidence items0 based on the context it is used
func (m *CosmosBlockBlockEvidenceEvidenceItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDuplicateVoteEvidence(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLightClientAttackEvidence(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0) contextValidateDuplicateVoteEvidence(ctx context.Context, formats strfmt.Registry) error {

	if m.DuplicateVoteEvidence != nil {

		if swag.IsZero(m.DuplicateVoteEvidence) { // not required
			return nil
		}

		if err := m.DuplicateVoteEvidence.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0) contextValidateLightClientAttackEvidence(ctx context.Context, formats strfmt.Registry) error {

	if m.LightClientAttackEvidence != nil {

		if swag.IsZero(m.LightClientAttackEvidence) { // not required
			return nil
		}

		if err := m.LightClientAttackEvidence.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockEvidenceEvidenceItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidence cosmos block block evidence evidence items0 duplicate vote evidence
//
// swagger:model CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidence
type CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidence struct {

	// timestamp
	// Format: date-time
	Timestamp strfmt.DateTime `json:"timestamp,omitempty"`

	// total voting power
	TotalVotingPower string `json:"total_voting_power,omitempty"`

	// validator power
	ValidatorPower string `json:"validator_power,omitempty"`

	// vote a
	Votea *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea `json:"vote_a,omitempty"`

	// vote b
	Voteb *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb `json:"vote_b,omitempty"`
}

// Validate validates this cosmos block block evidence evidence items0 duplicate vote evidence
func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidence) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVotea(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVoteb(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidence) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("duplicate_vote_evidence"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidence) validateVotea(formats strfmt.Registry) error {
	if swag.IsZero(m.Votea) { // not required
		return nil
	}

	if m.Votea != nil {
		if err := m.Votea.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_a")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_a")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidence) validateVoteb(formats strfmt.Registry) error {
	if swag.IsZero(m.Voteb) { // not required
		return nil
	}

	if m.Voteb != nil {
		if err := m.Voteb.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_b")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_b")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos block block evidence evidence items0 duplicate vote evidence based on the context it is used
func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidence) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateVotea(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVoteb(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidence) contextValidateVotea(ctx context.Context, formats strfmt.Registry) error {

	if m.Votea != nil {

		if swag.IsZero(m.Votea) { // not required
			return nil
		}

		if err := m.Votea.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_a")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_a")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidence) contextValidateVoteb(ctx context.Context, formats strfmt.Registry) error {

	if m.Voteb != nil {

		if swag.IsZero(m.Voteb) { // not required
			return nil
		}

		if err := m.Voteb.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_b")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_b")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidence) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidence) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidence
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea cosmos block block evidence evidence items0 duplicate vote evidence votea
//
// swagger:model CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea
type CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea struct {

	// block id
	BlockID *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID `json:"block_id,omitempty"`

	// extension
	// Format: byte
	Extension strfmt.Base64 `json:"extension,omitempty"`

	// extension signature
	// Format: byte
	ExtensionSignature strfmt.Base64 `json:"extension_signature,omitempty"`

	// height
	Height string `json:"height,omitempty"`

	// round
	Round int32 `json:"round,omitempty"`

	// signature
	// Format: byte
	Signature strfmt.Base64 `json:"signature,omitempty"`

	// timestamp
	// Format: date-time
	Timestamp strfmt.DateTime `json:"timestamp,omitempty"`

	// type
	// Enum: ["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"]
	Type *string `json:"type,omitempty"`

	// validator address
	// Format: byte
	ValidatorAddress strfmt.Base64 `json:"validator_address,omitempty"`

	// validator index
	ValidatorIndex int32 `json:"validator_index,omitempty"`
}

// Validate validates this cosmos block block evidence evidence items0 duplicate vote evidence votea
func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) validateBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockID) { // not required
		return nil
	}

	if m.BlockID != nil {
		if err := m.BlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("duplicate_vote_evidence"+"."+"vote_a"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

var cosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		cosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeTypePropEnum = append(cosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeTypePropEnum, v)
	}
}

const (

	// CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEUNKNOWN captures enum value "SIGNED_MSG_TYPE_UNKNOWN"
	CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEUNKNOWN string = "SIGNED_MSG_TYPE_UNKNOWN"

	// CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEPREVOTE captures enum value "SIGNED_MSG_TYPE_PREVOTE"
	CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEPREVOTE string = "SIGNED_MSG_TYPE_PREVOTE"

	// CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEPRECOMMIT captures enum value "SIGNED_MSG_TYPE_PRECOMMIT"
	CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEPRECOMMIT string = "SIGNED_MSG_TYPE_PRECOMMIT"

	// CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEPROPOSAL captures enum value "SIGNED_MSG_TYPE_PROPOSAL"
	CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEPROPOSAL string = "SIGNED_MSG_TYPE_PROPOSAL"
)

// prop value enum
func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, cosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("duplicate_vote_evidence"+"."+"vote_a"+"."+"type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cosmos block block evidence evidence items0 duplicate vote evidence votea based on the context it is used
func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) contextValidateBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.BlockID != nil {

		if swag.IsZero(m.BlockID) { // not required
			return nil
		}

		if err := m.BlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID cosmos block block evidence evidence items0 duplicate vote evidence votea block ID
//
// swagger:model CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID
type CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this cosmos block block evidence evidence items0 duplicate vote evidence votea block ID
func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos block block evidence evidence items0 duplicate vote evidence votea block ID based on the context it is used
func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {

		if swag.IsZero(m.PartSetHeader) { // not required
			return nil
		}

		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader cosmos block block evidence evidence items0 duplicate vote evidence votea block ID part set header
//
// swagger:model CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader
type CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this cosmos block block evidence evidence items0 duplicate vote evidence votea block ID part set header
func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos block block evidence evidence items0 duplicate vote evidence votea block ID part set header based on context it is used
func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb cosmos block block evidence evidence items0 duplicate vote evidence voteb
//
// swagger:model CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb
type CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb struct {

	// block id
	BlockID *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID `json:"block_id,omitempty"`

	// extension
	// Format: byte
	Extension strfmt.Base64 `json:"extension,omitempty"`

	// extension signature
	// Format: byte
	ExtensionSignature strfmt.Base64 `json:"extension_signature,omitempty"`

	// height
	Height string `json:"height,omitempty"`

	// round
	Round int32 `json:"round,omitempty"`

	// signature
	// Format: byte
	Signature strfmt.Base64 `json:"signature,omitempty"`

	// timestamp
	// Format: date-time
	Timestamp strfmt.DateTime `json:"timestamp,omitempty"`

	// type
	// Enum: ["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"]
	Type *string `json:"type,omitempty"`

	// validator address
	// Format: byte
	ValidatorAddress strfmt.Base64 `json:"validator_address,omitempty"`

	// validator index
	ValidatorIndex int32 `json:"validator_index,omitempty"`
}

// Validate validates this cosmos block block evidence evidence items0 duplicate vote evidence voteb
func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) validateBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockID) { // not required
		return nil
	}

	if m.BlockID != nil {
		if err := m.BlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("duplicate_vote_evidence"+"."+"vote_b"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

var cosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		cosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeTypePropEnum = append(cosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeTypePropEnum, v)
	}
}

const (

	// CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEUNKNOWN captures enum value "SIGNED_MSG_TYPE_UNKNOWN"
	CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEUNKNOWN string = "SIGNED_MSG_TYPE_UNKNOWN"

	// CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEPREVOTE captures enum value "SIGNED_MSG_TYPE_PREVOTE"
	CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEPREVOTE string = "SIGNED_MSG_TYPE_PREVOTE"

	// CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEPRECOMMIT captures enum value "SIGNED_MSG_TYPE_PRECOMMIT"
	CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEPRECOMMIT string = "SIGNED_MSG_TYPE_PRECOMMIT"

	// CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEPROPOSAL captures enum value "SIGNED_MSG_TYPE_PROPOSAL"
	CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEPROPOSAL string = "SIGNED_MSG_TYPE_PROPOSAL"
)

// prop value enum
func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, cosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("duplicate_vote_evidence"+"."+"vote_b"+"."+"type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cosmos block block evidence evidence items0 duplicate vote evidence voteb based on the context it is used
func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) contextValidateBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.BlockID != nil {

		if swag.IsZero(m.BlockID) { // not required
			return nil
		}

		if err := m.BlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID cosmos block block evidence evidence items0 duplicate vote evidence voteb block ID
//
// swagger:model CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID
type CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this cosmos block block evidence evidence items0 duplicate vote evidence voteb block ID
func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos block block evidence evidence items0 duplicate vote evidence voteb block ID based on the context it is used
func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {

		if swag.IsZero(m.PartSetHeader) { // not required
			return nil
		}

		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader cosmos block block evidence evidence items0 duplicate vote evidence voteb block ID part set header
//
// swagger:model CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader
type CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this cosmos block block evidence evidence items0 duplicate vote evidence voteb block ID part set header
func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos block block evidence evidence items0 duplicate vote evidence voteb block ID part set header based on context it is used
func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidence cosmos block block evidence evidence items0 light client attack evidence
//
// swagger:model CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidence
type CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidence struct {

	// byzantine validators
	ByzantineValidators []*CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0 `json:"byzantine_validators"`

	// common height
	CommonHeight string `json:"common_height,omitempty"`

	// conflicting block
	ConflictingBlock *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock `json:"conflicting_block,omitempty"`

	// timestamp
	// Format: date-time
	Timestamp strfmt.DateTime `json:"timestamp,omitempty"`

	// total voting power
	TotalVotingPower string `json:"total_voting_power,omitempty"`
}

// Validate validates this cosmos block block evidence evidence items0 light client attack evidence
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidence) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateByzantineValidators(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConflictingBlock(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidence) validateByzantineValidators(formats strfmt.Registry) error {
	if swag.IsZero(m.ByzantineValidators) { // not required
		return nil
	}

	for i := 0; i < len(m.ByzantineValidators); i++ {
		if swag.IsZero(m.ByzantineValidators[i]) { // not required
			continue
		}

		if m.ByzantineValidators[i] != nil {
			if err := m.ByzantineValidators[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("light_client_attack_evidence" + "." + "byzantine_validators" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("light_client_attack_evidence" + "." + "byzantine_validators" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidence) validateConflictingBlock(formats strfmt.Registry) error {
	if swag.IsZero(m.ConflictingBlock) { // not required
		return nil
	}

	if m.ConflictingBlock != nil {
		if err := m.ConflictingBlock.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidence) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("light_client_attack_evidence"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cosmos block block evidence evidence items0 light client attack evidence based on the context it is used
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidence) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateByzantineValidators(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConflictingBlock(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidence) contextValidateByzantineValidators(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ByzantineValidators); i++ {

		if m.ByzantineValidators[i] != nil {

			if swag.IsZero(m.ByzantineValidators[i]) { // not required
				return nil
			}

			if err := m.ByzantineValidators[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("light_client_attack_evidence" + "." + "byzantine_validators" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("light_client_attack_evidence" + "." + "byzantine_validators" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidence) contextValidateConflictingBlock(ctx context.Context, formats strfmt.Registry) error {

	if m.ConflictingBlock != nil {

		if swag.IsZero(m.ConflictingBlock) { // not required
			return nil
		}

		if err := m.ConflictingBlock.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidence) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidence) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidence
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0 cosmos block block evidence evidence items0 light client attack evidence byzantine validators items0
//
// swagger:model CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0
type CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0 struct {

	// address
	// Format: byte
	Address strfmt.Base64 `json:"address,omitempty"`

	// proposer priority
	ProposerPriority string `json:"proposer_priority,omitempty"`

	// pub key
	PubKey *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey `json:"pub_key,omitempty"`

	// voting power
	VotingPower string `json:"voting_power,omitempty"`
}

// Validate validates this cosmos block block evidence evidence items0 light client attack evidence byzantine validators items0
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePubKey(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0) validatePubKey(formats strfmt.Registry) error {
	if swag.IsZero(m.PubKey) { // not required
		return nil
	}

	if m.PubKey != nil {
		if err := m.PubKey.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pub_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("pub_key")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos block block evidence evidence items0 light client attack evidence byzantine validators items0 based on the context it is used
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePubKey(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0) contextValidatePubKey(ctx context.Context, formats strfmt.Registry) error {

	if m.PubKey != nil {

		if swag.IsZero(m.PubKey) { // not required
			return nil
		}

		if err := m.PubKey.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pub_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("pub_key")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey cosmos block block evidence evidence items0 light client attack evidence byzantine validators items0 pub key
//
// swagger:model CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey
type CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey struct {

	// ed25519
	// Format: byte
	Ed25519 strfmt.Base64 `json:"ed25519,omitempty"`

	// secp256k1
	// Format: byte
	Secp256k1 strfmt.Base64 `json:"secp256k1,omitempty"`
}

// Validate validates this cosmos block block evidence evidence items0 light client attack evidence byzantine validators items0 pub key
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos block block evidence evidence items0 light client attack evidence byzantine validators items0 pub key based on context it is used
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock cosmos block block evidence evidence items0 light client attack evidence conflicting block
//
// swagger:model CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock
type CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock struct {

	// signed header
	SignedHeader *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader `json:"signed_header,omitempty"`

	// validator set
	ValidatorSet *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet `json:"validator_set,omitempty"`
}

// Validate validates this cosmos block block evidence evidence items0 light client attack evidence conflicting block
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSignedHeader(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidatorSet(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) validateSignedHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.SignedHeader) { // not required
		return nil
	}

	if m.SignedHeader != nil {
		if err := m.SignedHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) validateValidatorSet(formats strfmt.Registry) error {
	if swag.IsZero(m.ValidatorSet) { // not required
		return nil
	}

	if m.ValidatorSet != nil {
		if err := m.ValidatorSet.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos block block evidence evidence items0 light client attack evidence conflicting block based on the context it is used
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSignedHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateValidatorSet(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) contextValidateSignedHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.SignedHeader != nil {

		if swag.IsZero(m.SignedHeader) { // not required
			return nil
		}

		if err := m.SignedHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) contextValidateValidatorSet(ctx context.Context, formats strfmt.Registry) error {

	if m.ValidatorSet != nil {

		if swag.IsZero(m.ValidatorSet) { // not required
			return nil
		}

		if err := m.ValidatorSet.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader cosmos block block evidence evidence items0 light client attack evidence conflicting block signed header
//
// swagger:model CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader
type CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader struct {

	// commit
	Commit *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit `json:"commit,omitempty"`

	// header
	Header *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader `json:"header,omitempty"`
}

// Validate validates this cosmos block block evidence evidence items0 light client attack evidence conflicting block signed header
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCommit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) validateCommit(formats strfmt.Registry) error {
	if swag.IsZero(m.Commit) { // not required
		return nil
	}

	if m.Commit != nil {
		if err := m.Commit.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) validateHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.Header) { // not required
		return nil
	}

	if m.Header != nil {
		if err := m.Header.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos block block evidence evidence items0 light client attack evidence conflicting block signed header based on the context it is used
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCommit(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) contextValidateCommit(ctx context.Context, formats strfmt.Registry) error {

	if m.Commit != nil {

		if swag.IsZero(m.Commit) { // not required
			return nil
		}

		if err := m.Commit.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) contextValidateHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.Header != nil {

		if swag.IsZero(m.Header) { // not required
			return nil
		}

		if err := m.Header.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit cosmos block block evidence evidence items0 light client attack evidence conflicting block signed header commit
//
// swagger:model CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit
type CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit struct {

	// block id
	BlockID *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID `json:"block_id,omitempty"`

	// height
	Height string `json:"height,omitempty"`

	// round
	Round int32 `json:"round,omitempty"`

	// signatures
	Signatures []*CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0 `json:"signatures"`
}

// Validate validates this cosmos block block evidence evidence items0 light client attack evidence conflicting block signed header commit
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSignatures(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) validateBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockID) { // not required
		return nil
	}

	if m.BlockID != nil {
		if err := m.BlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) validateSignatures(formats strfmt.Registry) error {
	if swag.IsZero(m.Signatures) { // not required
		return nil
	}

	for i := 0; i < len(m.Signatures); i++ {
		if swag.IsZero(m.Signatures[i]) { // not required
			continue
		}

		if m.Signatures[i] != nil {
			if err := m.Signatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "signatures" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "signatures" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this cosmos block block evidence evidence items0 light client attack evidence conflicting block signed header commit based on the context it is used
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSignatures(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) contextValidateBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.BlockID != nil {

		if swag.IsZero(m.BlockID) { // not required
			return nil
		}

		if err := m.BlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) contextValidateSignatures(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Signatures); i++ {

		if m.Signatures[i] != nil {

			if swag.IsZero(m.Signatures[i]) { // not required
				return nil
			}

			if err := m.Signatures[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "signatures" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "signatures" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID cosmos block block evidence evidence items0 light client attack evidence conflicting block signed header commit block ID
//
// swagger:model CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID
type CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this cosmos block block evidence evidence items0 light client attack evidence conflicting block signed header commit block ID
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos block block evidence evidence items0 light client attack evidence conflicting block signed header commit block ID based on the context it is used
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {

		if swag.IsZero(m.PartSetHeader) { // not required
			return nil
		}

		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader cosmos block block evidence evidence items0 light client attack evidence conflicting block signed header commit block ID part set header
//
// swagger:model CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader
type CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this cosmos block block evidence evidence items0 light client attack evidence conflicting block signed header commit block ID part set header
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos block block evidence evidence items0 light client attack evidence conflicting block signed header commit block ID part set header based on context it is used
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0 cosmos block block evidence evidence items0 light client attack evidence conflicting block signed header commit signatures items0
//
// swagger:model CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0
type CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0 struct {

	// block id flag
	// Enum: ["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"]
	BlockIDFlag *string `json:"block_id_flag,omitempty"`

	// signature
	// Format: byte
	Signature strfmt.Base64 `json:"signature,omitempty"`

	// timestamp
	// Format: date-time
	Timestamp strfmt.DateTime `json:"timestamp,omitempty"`

	// validator address
	// Format: byte
	ValidatorAddress strfmt.Base64 `json:"validator_address,omitempty"`
}

// Validate validates this cosmos block block evidence evidence items0 light client attack evidence conflicting block signed header commit signatures items0
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockIDFlag(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var cosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0TypeBlockIDFlagPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		cosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0TypeBlockIDFlagPropEnum = append(cosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0TypeBlockIDFlagPropEnum, v)
	}
}

const (

	// CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGUNKNOWN captures enum value "BLOCK_ID_FLAG_UNKNOWN"
	CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGUNKNOWN string = "BLOCK_ID_FLAG_UNKNOWN"

	// CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGABSENT captures enum value "BLOCK_ID_FLAG_ABSENT"
	CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGABSENT string = "BLOCK_ID_FLAG_ABSENT"

	// CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGCOMMIT captures enum value "BLOCK_ID_FLAG_COMMIT"
	CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGCOMMIT string = "BLOCK_ID_FLAG_COMMIT"

	// CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGNIL captures enum value "BLOCK_ID_FLAG_NIL"
	CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGNIL string = "BLOCK_ID_FLAG_NIL"
)

// prop value enum
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) validateBlockIDFlagEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, cosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0TypeBlockIDFlagPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) validateBlockIDFlag(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockIDFlag) { // not required
		return nil
	}

	// value enum
	if err := m.validateBlockIDFlagEnum("block_id_flag", "body", *m.BlockIDFlag); err != nil {
		return err
	}

	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this cosmos block block evidence evidence items0 light client attack evidence conflicting block signed header commit signatures items0 based on context it is used
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader cosmos block block evidence evidence items0 light client attack evidence conflicting block signed header header
//
// swagger:model CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader
type CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader struct {

	// app hash
	// Format: byte
	AppHash strfmt.Base64 `json:"app_hash,omitempty"`

	// chain id
	ChainID string `json:"chain_id,omitempty"`

	// consensus hash
	// Format: byte
	ConsensusHash strfmt.Base64 `json:"consensus_hash,omitempty"`

	// data hash
	// Format: byte
	DataHash strfmt.Base64 `json:"data_hash,omitempty"`

	// evidence hash
	// Format: byte
	EvidenceHash strfmt.Base64 `json:"evidence_hash,omitempty"`

	// height
	Height string `json:"height,omitempty"`

	// last block id
	LastBlockID *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID `json:"last_block_id,omitempty"`

	// last commit hash
	// Format: byte
	LastCommitHash strfmt.Base64 `json:"last_commit_hash,omitempty"`

	// last results hash
	// Format: byte
	LastResultsHash strfmt.Base64 `json:"last_results_hash,omitempty"`

	// next validators hash
	// Format: byte
	NextValidatorsHash strfmt.Base64 `json:"next_validators_hash,omitempty"`

	// proposer address
	// Format: byte
	ProposerAddress strfmt.Base64 `json:"proposer_address,omitempty"`

	// time
	// Format: date-time
	Time strfmt.DateTime `json:"time,omitempty"`

	// validators hash
	// Format: byte
	ValidatorsHash strfmt.Base64 `json:"validators_hash,omitempty"`

	// version
	Version *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion `json:"version,omitempty"`
}

// Validate validates this cosmos block block evidence evidence items0 light client attack evidence conflicting block signed header header
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLastBlockID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) validateLastBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.LastBlockID) { // not required
		return nil
	}

	if m.LastBlockID != nil {
		if err := m.LastBlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) validateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.Time) { // not required
		return nil
	}

	if err := validate.FormatOf("light_client_attack_evidence"+"."+"conflicting_block"+"."+"signed_header"+"."+"header"+"."+"time", "body", "date-time", m.Time.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) validateVersion(formats strfmt.Registry) error {
	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if m.Version != nil {
		if err := m.Version.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "version")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "version")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos block block evidence evidence items0 light client attack evidence conflicting block signed header header based on the context it is used
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLastBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) contextValidateLastBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.LastBlockID != nil {

		if swag.IsZero(m.LastBlockID) { // not required
			return nil
		}

		if err := m.LastBlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) contextValidateVersion(ctx context.Context, formats strfmt.Registry) error {

	if m.Version != nil {

		if swag.IsZero(m.Version) { // not required
			return nil
		}

		if err := m.Version.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "version")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "version")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID cosmos block block evidence evidence items0 light client attack evidence conflicting block signed header header last block ID
//
// swagger:model CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID
type CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this cosmos block block evidence evidence items0 light client attack evidence conflicting block signed header header last block ID
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos block block evidence evidence items0 light client attack evidence conflicting block signed header header last block ID based on the context it is used
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {

		if swag.IsZero(m.PartSetHeader) { // not required
			return nil
		}

		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader cosmos block block evidence evidence items0 light client attack evidence conflicting block signed header header last block ID part set header
//
// swagger:model CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader
type CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this cosmos block block evidence evidence items0 light client attack evidence conflicting block signed header header last block ID part set header
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos block block evidence evidence items0 light client attack evidence conflicting block signed header header last block ID part set header based on context it is used
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion cosmos block block evidence evidence items0 light client attack evidence conflicting block signed header header version
//
// swagger:model CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion
type CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion struct {

	// app
	App string `json:"app,omitempty"`

	// block
	Block string `json:"block,omitempty"`
}

// Validate validates this cosmos block block evidence evidence items0 light client attack evidence conflicting block signed header header version
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos block block evidence evidence items0 light client attack evidence conflicting block signed header header version based on context it is used
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet cosmos block block evidence evidence items0 light client attack evidence conflicting block validator set
//
// swagger:model CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet
type CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet struct {

	// proposer
	Proposer *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer `json:"proposer,omitempty"`

	// total voting power
	TotalVotingPower string `json:"total_voting_power,omitempty"`

	// validators
	Validators []*CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0 `json:"validators"`
}

// Validate validates this cosmos block block evidence evidence items0 light client attack evidence conflicting block validator set
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateProposer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidators(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) validateProposer(formats strfmt.Registry) error {
	if swag.IsZero(m.Proposer) { // not required
		return nil
	}

	if m.Proposer != nil {
		if err := m.Proposer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) validateValidators(formats strfmt.Registry) error {
	if swag.IsZero(m.Validators) { // not required
		return nil
	}

	for i := 0; i < len(m.Validators); i++ {
		if swag.IsZero(m.Validators[i]) { // not required
			continue
		}

		if m.Validators[i] != nil {
			if err := m.Validators[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "validators" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "validators" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this cosmos block block evidence evidence items0 light client attack evidence conflicting block validator set based on the context it is used
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateProposer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateValidators(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) contextValidateProposer(ctx context.Context, formats strfmt.Registry) error {

	if m.Proposer != nil {

		if swag.IsZero(m.Proposer) { // not required
			return nil
		}

		if err := m.Proposer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) contextValidateValidators(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Validators); i++ {

		if m.Validators[i] != nil {

			if swag.IsZero(m.Validators[i]) { // not required
				return nil
			}

			if err := m.Validators[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "validators" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "validators" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer cosmos block block evidence evidence items0 light client attack evidence conflicting block validator set proposer
//
// swagger:model CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer
type CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer struct {

	// address
	// Format: byte
	Address strfmt.Base64 `json:"address,omitempty"`

	// proposer priority
	ProposerPriority string `json:"proposer_priority,omitempty"`

	// pub key
	PubKey *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey `json:"pub_key,omitempty"`

	// voting power
	VotingPower string `json:"voting_power,omitempty"`
}

// Validate validates this cosmos block block evidence evidence items0 light client attack evidence conflicting block validator set proposer
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePubKey(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer) validatePubKey(formats strfmt.Registry) error {
	if swag.IsZero(m.PubKey) { // not required
		return nil
	}

	if m.PubKey != nil {
		if err := m.PubKey.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer" + "." + "pub_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer" + "." + "pub_key")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos block block evidence evidence items0 light client attack evidence conflicting block validator set proposer based on the context it is used
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePubKey(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer) contextValidatePubKey(ctx context.Context, formats strfmt.Registry) error {

	if m.PubKey != nil {

		if swag.IsZero(m.PubKey) { // not required
			return nil
		}

		if err := m.PubKey.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer" + "." + "pub_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer" + "." + "pub_key")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey cosmos block block evidence evidence items0 light client attack evidence conflicting block validator set proposer pub key
//
// swagger:model CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey
type CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey struct {

	// ed25519
	// Format: byte
	Ed25519 strfmt.Base64 `json:"ed25519,omitempty"`

	// secp256k1
	// Format: byte
	Secp256k1 strfmt.Base64 `json:"secp256k1,omitempty"`
}

// Validate validates this cosmos block block evidence evidence items0 light client attack evidence conflicting block validator set proposer pub key
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos block block evidence evidence items0 light client attack evidence conflicting block validator set proposer pub key based on context it is used
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0 cosmos block block evidence evidence items0 light client attack evidence conflicting block validator set validators items0
//
// swagger:model CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0
type CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0 struct {

	// address
	// Format: byte
	Address strfmt.Base64 `json:"address,omitempty"`

	// proposer priority
	ProposerPriority string `json:"proposer_priority,omitempty"`

	// pub key
	PubKey *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey `json:"pub_key,omitempty"`

	// voting power
	VotingPower string `json:"voting_power,omitempty"`
}

// Validate validates this cosmos block block evidence evidence items0 light client attack evidence conflicting block validator set validators items0
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePubKey(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0) validatePubKey(formats strfmt.Registry) error {
	if swag.IsZero(m.PubKey) { // not required
		return nil
	}

	if m.PubKey != nil {
		if err := m.PubKey.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pub_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("pub_key")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos block block evidence evidence items0 light client attack evidence conflicting block validator set validators items0 based on the context it is used
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePubKey(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0) contextValidatePubKey(ctx context.Context, formats strfmt.Registry) error {

	if m.PubKey != nil {

		if swag.IsZero(m.PubKey) { // not required
			return nil
		}

		if err := m.PubKey.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pub_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("pub_key")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey cosmos block block evidence evidence items0 light client attack evidence conflicting block validator set validators items0 pub key
//
// swagger:model CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey
type CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey struct {

	// ed25519
	// Format: byte
	Ed25519 strfmt.Base64 `json:"ed25519,omitempty"`

	// secp256k1
	// Format: byte
	Secp256k1 strfmt.Base64 `json:"secp256k1,omitempty"`
}

// Validate validates this cosmos block block evidence evidence items0 light client attack evidence conflicting block validator set validators items0 pub key
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos block block evidence evidence items0 light client attack evidence conflicting block validator set validators items0 pub key based on context it is used
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockHeader cosmos block block header
//
// swagger:model CosmosBlockBlockHeader
type CosmosBlockBlockHeader struct {

	// app hash
	// Format: byte
	AppHash strfmt.Base64 `json:"app_hash,omitempty"`

	// chain id
	ChainID string `json:"chain_id,omitempty"`

	// consensus hash
	// Format: byte
	ConsensusHash strfmt.Base64 `json:"consensus_hash,omitempty"`

	// data hash
	// Format: byte
	DataHash strfmt.Base64 `json:"data_hash,omitempty"`

	// evidence hash
	// Format: byte
	EvidenceHash strfmt.Base64 `json:"evidence_hash,omitempty"`

	// height
	Height string `json:"height,omitempty"`

	// last block id
	LastBlockID *CosmosBlockBlockHeaderLastBlockID `json:"last_block_id,omitempty"`

	// last commit hash
	// Format: byte
	LastCommitHash strfmt.Base64 `json:"last_commit_hash,omitempty"`

	// last results hash
	// Format: byte
	LastResultsHash strfmt.Base64 `json:"last_results_hash,omitempty"`

	// next validators hash
	// Format: byte
	NextValidatorsHash strfmt.Base64 `json:"next_validators_hash,omitempty"`

	// proposer address
	// Format: byte
	ProposerAddress strfmt.Base64 `json:"proposer_address,omitempty"`

	// time
	// Format: date-time
	Time strfmt.DateTime `json:"time,omitempty"`

	// validators hash
	// Format: byte
	ValidatorsHash strfmt.Base64 `json:"validators_hash,omitempty"`

	// version
	Version *CosmosBlockBlockHeaderVersion `json:"version,omitempty"`
}

// Validate validates this cosmos block block header
func (m *CosmosBlockBlockHeader) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLastBlockID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockHeader) validateLastBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.LastBlockID) { // not required
		return nil
	}

	if m.LastBlockID != nil {
		if err := m.LastBlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "header" + "." + "last_block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "header" + "." + "last_block_id")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockBlockHeader) validateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.Time) { // not required
		return nil
	}

	if err := validate.FormatOf("block"+"."+"header"+"."+"time", "body", "date-time", m.Time.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CosmosBlockBlockHeader) validateVersion(formats strfmt.Registry) error {
	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if m.Version != nil {
		if err := m.Version.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "header" + "." + "version")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "header" + "." + "version")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos block block header based on the context it is used
func (m *CosmosBlockBlockHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLastBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockHeader) contextValidateLastBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.LastBlockID != nil {

		if swag.IsZero(m.LastBlockID) { // not required
			return nil
		}

		if err := m.LastBlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "header" + "." + "last_block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "header" + "." + "last_block_id")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockBlockHeader) contextValidateVersion(ctx context.Context, formats strfmt.Registry) error {

	if m.Version != nil {

		if swag.IsZero(m.Version) { // not required
			return nil
		}

		if err := m.Version.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "header" + "." + "version")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "header" + "." + "version")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockHeader) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockHeaderLastBlockID cosmos block block header last block ID
//
// swagger:model CosmosBlockBlockHeaderLastBlockID
type CosmosBlockBlockHeaderLastBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *CosmosBlockBlockHeaderLastBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this cosmos block block header last block ID
func (m *CosmosBlockBlockHeaderLastBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockHeaderLastBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos block block header last block ID based on the context it is used
func (m *CosmosBlockBlockHeaderLastBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockHeaderLastBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {

		if swag.IsZero(m.PartSetHeader) { // not required
			return nil
		}

		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockHeaderLastBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockHeaderLastBlockID) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockHeaderLastBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockHeaderLastBlockIDPartSetHeader cosmos block block header last block ID part set header
//
// swagger:model CosmosBlockBlockHeaderLastBlockIDPartSetHeader
type CosmosBlockBlockHeaderLastBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this cosmos block block header last block ID part set header
func (m *CosmosBlockBlockHeaderLastBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos block block header last block ID part set header based on context it is used
func (m *CosmosBlockBlockHeaderLastBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockHeaderLastBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockHeaderLastBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockHeaderLastBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockHeaderVersion cosmos block block header version
//
// swagger:model CosmosBlockBlockHeaderVersion
type CosmosBlockBlockHeaderVersion struct {

	// app
	App string `json:"app,omitempty"`

	// block
	Block string `json:"block,omitempty"`
}

// Validate validates this cosmos block block header version
func (m *CosmosBlockBlockHeaderVersion) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos block block header version based on context it is used
func (m *CosmosBlockBlockHeaderVersion) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockHeaderVersion) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockHeaderVersion) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockHeaderVersion
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockID cosmos block block ID
//
// swagger:model CosmosBlockBlockID
type CosmosBlockBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *CosmosBlockBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this cosmos block block ID
func (m *CosmosBlockBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos block block ID based on the context it is used
func (m *CosmosBlockBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {

		if swag.IsZero(m.PartSetHeader) { // not required
			return nil
		}

		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockID) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockIDPartSetHeader cosmos block block ID part set header
//
// swagger:model CosmosBlockBlockIDPartSetHeader
type CosmosBlockBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this cosmos block block ID part set header
func (m *CosmosBlockBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos block block ID part set header based on context it is used
func (m *CosmosBlockBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockLastCommit cosmos block block last commit
//
// swagger:model CosmosBlockBlockLastCommit
type CosmosBlockBlockLastCommit struct {

	// block id
	BlockID *CosmosBlockBlockLastCommitBlockID `json:"block_id,omitempty"`

	// height
	Height string `json:"height,omitempty"`

	// round
	Round int32 `json:"round,omitempty"`

	// signatures
	Signatures []*CosmosBlockBlockLastCommitSignaturesItems0 `json:"signatures"`
}

// Validate validates this cosmos block block last commit
func (m *CosmosBlockBlockLastCommit) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSignatures(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockLastCommit) validateBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockID) { // not required
		return nil
	}

	if m.BlockID != nil {
		if err := m.BlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "last_commit" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "last_commit" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockBlockLastCommit) validateSignatures(formats strfmt.Registry) error {
	if swag.IsZero(m.Signatures) { // not required
		return nil
	}

	for i := 0; i < len(m.Signatures); i++ {
		if swag.IsZero(m.Signatures[i]) { // not required
			continue
		}

		if m.Signatures[i] != nil {
			if err := m.Signatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("block" + "." + "last_commit" + "." + "signatures" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("block" + "." + "last_commit" + "." + "signatures" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this cosmos block block last commit based on the context it is used
func (m *CosmosBlockBlockLastCommit) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSignatures(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockLastCommit) contextValidateBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.BlockID != nil {

		if swag.IsZero(m.BlockID) { // not required
			return nil
		}

		if err := m.BlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "last_commit" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "last_commit" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockBlockLastCommit) contextValidateSignatures(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Signatures); i++ {

		if m.Signatures[i] != nil {

			if swag.IsZero(m.Signatures[i]) { // not required
				return nil
			}

			if err := m.Signatures[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("block" + "." + "last_commit" + "." + "signatures" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("block" + "." + "last_commit" + "." + "signatures" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockLastCommit) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockLastCommit) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockLastCommit
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockLastCommitBlockID cosmos block block last commit block ID
//
// swagger:model CosmosBlockBlockLastCommitBlockID
type CosmosBlockBlockLastCommitBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *CosmosBlockBlockLastCommitBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this cosmos block block last commit block ID
func (m *CosmosBlockBlockLastCommitBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockLastCommitBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "last_commit" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "last_commit" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos block block last commit block ID based on the context it is used
func (m *CosmosBlockBlockLastCommitBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockBlockLastCommitBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {

		if swag.IsZero(m.PartSetHeader) { // not required
			return nil
		}

		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "last_commit" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "last_commit" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockLastCommitBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockLastCommitBlockID) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockLastCommitBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockLastCommitBlockIDPartSetHeader cosmos block block last commit block ID part set header
//
// swagger:model CosmosBlockBlockLastCommitBlockIDPartSetHeader
type CosmosBlockBlockLastCommitBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this cosmos block block last commit block ID part set header
func (m *CosmosBlockBlockLastCommitBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos block block last commit block ID part set header based on context it is used
func (m *CosmosBlockBlockLastCommitBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockLastCommitBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockLastCommitBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockLastCommitBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockBlockLastCommitSignaturesItems0 cosmos block block last commit signatures items0
//
// swagger:model CosmosBlockBlockLastCommitSignaturesItems0
type CosmosBlockBlockLastCommitSignaturesItems0 struct {

	// block id flag
	// Enum: ["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"]
	BlockIDFlag *string `json:"block_id_flag,omitempty"`

	// signature
	// Format: byte
	Signature strfmt.Base64 `json:"signature,omitempty"`

	// timestamp
	// Format: date-time
	Timestamp strfmt.DateTime `json:"timestamp,omitempty"`

	// validator address
	// Format: byte
	ValidatorAddress strfmt.Base64 `json:"validator_address,omitempty"`
}

// Validate validates this cosmos block block last commit signatures items0
func (m *CosmosBlockBlockLastCommitSignaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockIDFlag(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var cosmosBlockBlockLastCommitSignaturesItems0TypeBlockIDFlagPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		cosmosBlockBlockLastCommitSignaturesItems0TypeBlockIDFlagPropEnum = append(cosmosBlockBlockLastCommitSignaturesItems0TypeBlockIDFlagPropEnum, v)
	}
}

const (

	// CosmosBlockBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGUNKNOWN captures enum value "BLOCK_ID_FLAG_UNKNOWN"
	CosmosBlockBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGUNKNOWN string = "BLOCK_ID_FLAG_UNKNOWN"

	// CosmosBlockBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGABSENT captures enum value "BLOCK_ID_FLAG_ABSENT"
	CosmosBlockBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGABSENT string = "BLOCK_ID_FLAG_ABSENT"

	// CosmosBlockBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGCOMMIT captures enum value "BLOCK_ID_FLAG_COMMIT"
	CosmosBlockBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGCOMMIT string = "BLOCK_ID_FLAG_COMMIT"

	// CosmosBlockBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGNIL captures enum value "BLOCK_ID_FLAG_NIL"
	CosmosBlockBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGNIL string = "BLOCK_ID_FLAG_NIL"
)

// prop value enum
func (m *CosmosBlockBlockLastCommitSignaturesItems0) validateBlockIDFlagEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, cosmosBlockBlockLastCommitSignaturesItems0TypeBlockIDFlagPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CosmosBlockBlockLastCommitSignaturesItems0) validateBlockIDFlag(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockIDFlag) { // not required
		return nil
	}

	// value enum
	if err := m.validateBlockIDFlagEnum("block_id_flag", "body", *m.BlockIDFlag); err != nil {
		return err
	}

	return nil
}

func (m *CosmosBlockBlockLastCommitSignaturesItems0) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this cosmos block block last commit signatures items0 based on context it is used
func (m *CosmosBlockBlockLastCommitSignaturesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockBlockLastCommitSignaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockBlockLastCommitSignaturesItems0) UnmarshalBinary(b []byte) error {
	var res CosmosBlockBlockLastCommitSignaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlock cosmos block sdk block
//
// swagger:model CosmosBlockSdkBlock
type CosmosBlockSdkBlock struct {

	// data
	Data *CosmosBlockSdkBlockData `json:"data,omitempty"`

	// evidence
	Evidence *CosmosBlockSdkBlockEvidence `json:"evidence,omitempty"`

	// header
	Header *CosmosBlockSdkBlockHeader `json:"header,omitempty"`

	// last commit
	LastCommit *CosmosBlockSdkBlockLastCommit `json:"last_commit,omitempty"`
}

// Validate validates this cosmos block sdk block
func (m *CosmosBlockSdkBlock) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateData(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEvidence(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHeader(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastCommit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlock) validateData(formats strfmt.Registry) error {
	if swag.IsZero(m.Data) { // not required
		return nil
	}

	if m.Data != nil {
		if err := m.Data.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sdk_block" + "." + "data")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sdk_block" + "." + "data")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockSdkBlock) validateEvidence(formats strfmt.Registry) error {
	if swag.IsZero(m.Evidence) { // not required
		return nil
	}

	if m.Evidence != nil {
		if err := m.Evidence.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sdk_block" + "." + "evidence")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sdk_block" + "." + "evidence")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockSdkBlock) validateHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.Header) { // not required
		return nil
	}

	if m.Header != nil {
		if err := m.Header.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sdk_block" + "." + "header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sdk_block" + "." + "header")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockSdkBlock) validateLastCommit(formats strfmt.Registry) error {
	if swag.IsZero(m.LastCommit) { // not required
		return nil
	}

	if m.LastCommit != nil {
		if err := m.LastCommit.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sdk_block" + "." + "last_commit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sdk_block" + "." + "last_commit")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos block sdk block based on the context it is used
func (m *CosmosBlockSdkBlock) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateData(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEvidence(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLastCommit(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlock) contextValidateData(ctx context.Context, formats strfmt.Registry) error {

	if m.Data != nil {

		if swag.IsZero(m.Data) { // not required
			return nil
		}

		if err := m.Data.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sdk_block" + "." + "data")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sdk_block" + "." + "data")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockSdkBlock) contextValidateEvidence(ctx context.Context, formats strfmt.Registry) error {

	if m.Evidence != nil {

		if swag.IsZero(m.Evidence) { // not required
			return nil
		}

		if err := m.Evidence.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sdk_block" + "." + "evidence")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sdk_block" + "." + "evidence")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockSdkBlock) contextValidateHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.Header != nil {

		if swag.IsZero(m.Header) { // not required
			return nil
		}

		if err := m.Header.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sdk_block" + "." + "header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sdk_block" + "." + "header")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockSdkBlock) contextValidateLastCommit(ctx context.Context, formats strfmt.Registry) error {

	if m.LastCommit != nil {

		if swag.IsZero(m.LastCommit) { // not required
			return nil
		}

		if err := m.LastCommit.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sdk_block" + "." + "last_commit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sdk_block" + "." + "last_commit")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlock) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlock) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlock
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlockData cosmos block sdk block data
//
// swagger:model CosmosBlockSdkBlockData
type CosmosBlockSdkBlockData struct {

	// txs
	Txs []strfmt.Base64 `json:"txs"`
}

// Validate validates this cosmos block sdk block data
func (m *CosmosBlockSdkBlockData) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos block sdk block data based on context it is used
func (m *CosmosBlockSdkBlockData) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlockData) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlockData) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlockData
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlockEvidence cosmos block sdk block evidence
//
// swagger:model CosmosBlockSdkBlockEvidence
type CosmosBlockSdkBlockEvidence struct {

	// evidence
	Evidence []*CosmosBlockSdkBlockEvidenceEvidenceItems0 `json:"evidence"`
}

// Validate validates this cosmos block sdk block evidence
func (m *CosmosBlockSdkBlockEvidence) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEvidence(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidence) validateEvidence(formats strfmt.Registry) error {
	if swag.IsZero(m.Evidence) { // not required
		return nil
	}

	for i := 0; i < len(m.Evidence); i++ {
		if swag.IsZero(m.Evidence[i]) { // not required
			continue
		}

		if m.Evidence[i] != nil {
			if err := m.Evidence[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("sdk_block" + "." + "evidence" + "." + "evidence" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("sdk_block" + "." + "evidence" + "." + "evidence" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this cosmos block sdk block evidence based on the context it is used
func (m *CosmosBlockSdkBlockEvidence) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateEvidence(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidence) contextValidateEvidence(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Evidence); i++ {

		if m.Evidence[i] != nil {

			if swag.IsZero(m.Evidence[i]) { // not required
				return nil
			}

			if err := m.Evidence[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("sdk_block" + "." + "evidence" + "." + "evidence" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("sdk_block" + "." + "evidence" + "." + "evidence" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidence) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidence) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlockEvidence
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlockEvidenceEvidenceItems0 cosmos block sdk block evidence evidence items0
//
// swagger:model CosmosBlockSdkBlockEvidenceEvidenceItems0
type CosmosBlockSdkBlockEvidenceEvidenceItems0 struct {

	// duplicate vote evidence
	DuplicateVoteEvidence *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidence `json:"duplicate_vote_evidence,omitempty"`

	// light client attack evidence
	LightClientAttackEvidence *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidence `json:"light_client_attack_evidence,omitempty"`
}

// Validate validates this cosmos block sdk block evidence evidence items0
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDuplicateVoteEvidence(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLightClientAttackEvidence(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0) validateDuplicateVoteEvidence(formats strfmt.Registry) error {
	if swag.IsZero(m.DuplicateVoteEvidence) { // not required
		return nil
	}

	if m.DuplicateVoteEvidence != nil {
		if err := m.DuplicateVoteEvidence.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0) validateLightClientAttackEvidence(formats strfmt.Registry) error {
	if swag.IsZero(m.LightClientAttackEvidence) { // not required
		return nil
	}

	if m.LightClientAttackEvidence != nil {
		if err := m.LightClientAttackEvidence.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos block sdk block evidence evidence items0 based on the context it is used
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDuplicateVoteEvidence(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLightClientAttackEvidence(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0) contextValidateDuplicateVoteEvidence(ctx context.Context, formats strfmt.Registry) error {

	if m.DuplicateVoteEvidence != nil {

		if swag.IsZero(m.DuplicateVoteEvidence) { // not required
			return nil
		}

		if err := m.DuplicateVoteEvidence.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0) contextValidateLightClientAttackEvidence(ctx context.Context, formats strfmt.Registry) error {

	if m.LightClientAttackEvidence != nil {

		if swag.IsZero(m.LightClientAttackEvidence) { // not required
			return nil
		}

		if err := m.LightClientAttackEvidence.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlockEvidenceEvidenceItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidence cosmos block sdk block evidence evidence items0 duplicate vote evidence
//
// swagger:model CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidence
type CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidence struct {

	// timestamp
	// Format: date-time
	Timestamp strfmt.DateTime `json:"timestamp,omitempty"`

	// total voting power
	TotalVotingPower string `json:"total_voting_power,omitempty"`

	// validator power
	ValidatorPower string `json:"validator_power,omitempty"`

	// vote a
	Votea *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea `json:"vote_a,omitempty"`

	// vote b
	Voteb *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb `json:"vote_b,omitempty"`
}

// Validate validates this cosmos block sdk block evidence evidence items0 duplicate vote evidence
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidence) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVotea(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVoteb(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidence) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("duplicate_vote_evidence"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidence) validateVotea(formats strfmt.Registry) error {
	if swag.IsZero(m.Votea) { // not required
		return nil
	}

	if m.Votea != nil {
		if err := m.Votea.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_a")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_a")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidence) validateVoteb(formats strfmt.Registry) error {
	if swag.IsZero(m.Voteb) { // not required
		return nil
	}

	if m.Voteb != nil {
		if err := m.Voteb.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_b")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_b")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos block sdk block evidence evidence items0 duplicate vote evidence based on the context it is used
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidence) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateVotea(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVoteb(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidence) contextValidateVotea(ctx context.Context, formats strfmt.Registry) error {

	if m.Votea != nil {

		if swag.IsZero(m.Votea) { // not required
			return nil
		}

		if err := m.Votea.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_a")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_a")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidence) contextValidateVoteb(ctx context.Context, formats strfmt.Registry) error {

	if m.Voteb != nil {

		if swag.IsZero(m.Voteb) { // not required
			return nil
		}

		if err := m.Voteb.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_b")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_b")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidence) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidence) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidence
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea cosmos block sdk block evidence evidence items0 duplicate vote evidence votea
//
// swagger:model CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea
type CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea struct {

	// block id
	BlockID *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID `json:"block_id,omitempty"`

	// extension
	// Format: byte
	Extension strfmt.Base64 `json:"extension,omitempty"`

	// extension signature
	// Format: byte
	ExtensionSignature strfmt.Base64 `json:"extension_signature,omitempty"`

	// height
	Height string `json:"height,omitempty"`

	// round
	Round int32 `json:"round,omitempty"`

	// signature
	// Format: byte
	Signature strfmt.Base64 `json:"signature,omitempty"`

	// timestamp
	// Format: date-time
	Timestamp strfmt.DateTime `json:"timestamp,omitempty"`

	// type
	// Enum: ["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"]
	Type *string `json:"type,omitempty"`

	// validator address
	// Format: byte
	ValidatorAddress strfmt.Base64 `json:"validator_address,omitempty"`

	// validator index
	ValidatorIndex int32 `json:"validator_index,omitempty"`
}

// Validate validates this cosmos block sdk block evidence evidence items0 duplicate vote evidence votea
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) validateBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockID) { // not required
		return nil
	}

	if m.BlockID != nil {
		if err := m.BlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("duplicate_vote_evidence"+"."+"vote_a"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

var cosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		cosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeTypePropEnum = append(cosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeTypePropEnum, v)
	}
}

const (

	// CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEUNKNOWN captures enum value "SIGNED_MSG_TYPE_UNKNOWN"
	CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEUNKNOWN string = "SIGNED_MSG_TYPE_UNKNOWN"

	// CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEPREVOTE captures enum value "SIGNED_MSG_TYPE_PREVOTE"
	CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEPREVOTE string = "SIGNED_MSG_TYPE_PREVOTE"

	// CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEPRECOMMIT captures enum value "SIGNED_MSG_TYPE_PRECOMMIT"
	CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEPRECOMMIT string = "SIGNED_MSG_TYPE_PRECOMMIT"

	// CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEPROPOSAL captures enum value "SIGNED_MSG_TYPE_PROPOSAL"
	CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEPROPOSAL string = "SIGNED_MSG_TYPE_PROPOSAL"
)

// prop value enum
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, cosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("duplicate_vote_evidence"+"."+"vote_a"+"."+"type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cosmos block sdk block evidence evidence items0 duplicate vote evidence votea based on the context it is used
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) contextValidateBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.BlockID != nil {

		if swag.IsZero(m.BlockID) { // not required
			return nil
		}

		if err := m.BlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID cosmos block sdk block evidence evidence items0 duplicate vote evidence votea block ID
//
// swagger:model CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID
type CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this cosmos block sdk block evidence evidence items0 duplicate vote evidence votea block ID
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos block sdk block evidence evidence items0 duplicate vote evidence votea block ID based on the context it is used
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {

		if swag.IsZero(m.PartSetHeader) { // not required
			return nil
		}

		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader cosmos block sdk block evidence evidence items0 duplicate vote evidence votea block ID part set header
//
// swagger:model CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader
type CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this cosmos block sdk block evidence evidence items0 duplicate vote evidence votea block ID part set header
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos block sdk block evidence evidence items0 duplicate vote evidence votea block ID part set header based on context it is used
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb cosmos block sdk block evidence evidence items0 duplicate vote evidence voteb
//
// swagger:model CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb
type CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb struct {

	// block id
	BlockID *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID `json:"block_id,omitempty"`

	// extension
	// Format: byte
	Extension strfmt.Base64 `json:"extension,omitempty"`

	// extension signature
	// Format: byte
	ExtensionSignature strfmt.Base64 `json:"extension_signature,omitempty"`

	// height
	Height string `json:"height,omitempty"`

	// round
	Round int32 `json:"round,omitempty"`

	// signature
	// Format: byte
	Signature strfmt.Base64 `json:"signature,omitempty"`

	// timestamp
	// Format: date-time
	Timestamp strfmt.DateTime `json:"timestamp,omitempty"`

	// type
	// Enum: ["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"]
	Type *string `json:"type,omitempty"`

	// validator address
	// Format: byte
	ValidatorAddress strfmt.Base64 `json:"validator_address,omitempty"`

	// validator index
	ValidatorIndex int32 `json:"validator_index,omitempty"`
}

// Validate validates this cosmos block sdk block evidence evidence items0 duplicate vote evidence voteb
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) validateBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockID) { // not required
		return nil
	}

	if m.BlockID != nil {
		if err := m.BlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("duplicate_vote_evidence"+"."+"vote_b"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

var cosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		cosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeTypePropEnum = append(cosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeTypePropEnum, v)
	}
}

const (

	// CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEUNKNOWN captures enum value "SIGNED_MSG_TYPE_UNKNOWN"
	CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEUNKNOWN string = "SIGNED_MSG_TYPE_UNKNOWN"

	// CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEPREVOTE captures enum value "SIGNED_MSG_TYPE_PREVOTE"
	CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEPREVOTE string = "SIGNED_MSG_TYPE_PREVOTE"

	// CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEPRECOMMIT captures enum value "SIGNED_MSG_TYPE_PRECOMMIT"
	CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEPRECOMMIT string = "SIGNED_MSG_TYPE_PRECOMMIT"

	// CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEPROPOSAL captures enum value "SIGNED_MSG_TYPE_PROPOSAL"
	CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEPROPOSAL string = "SIGNED_MSG_TYPE_PROPOSAL"
)

// prop value enum
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, cosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("duplicate_vote_evidence"+"."+"vote_b"+"."+"type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cosmos block sdk block evidence evidence items0 duplicate vote evidence voteb based on the context it is used
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) contextValidateBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.BlockID != nil {

		if swag.IsZero(m.BlockID) { // not required
			return nil
		}

		if err := m.BlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID cosmos block sdk block evidence evidence items0 duplicate vote evidence voteb block ID
//
// swagger:model CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID
type CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this cosmos block sdk block evidence evidence items0 duplicate vote evidence voteb block ID
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos block sdk block evidence evidence items0 duplicate vote evidence voteb block ID based on the context it is used
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {

		if swag.IsZero(m.PartSetHeader) { // not required
			return nil
		}

		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader cosmos block sdk block evidence evidence items0 duplicate vote evidence voteb block ID part set header
//
// swagger:model CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader
type CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this cosmos block sdk block evidence evidence items0 duplicate vote evidence voteb block ID part set header
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos block sdk block evidence evidence items0 duplicate vote evidence voteb block ID part set header based on context it is used
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidence cosmos block sdk block evidence evidence items0 light client attack evidence
//
// swagger:model CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidence
type CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidence struct {

	// byzantine validators
	ByzantineValidators []*CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0 `json:"byzantine_validators"`

	// common height
	CommonHeight string `json:"common_height,omitempty"`

	// conflicting block
	ConflictingBlock *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock `json:"conflicting_block,omitempty"`

	// timestamp
	// Format: date-time
	Timestamp strfmt.DateTime `json:"timestamp,omitempty"`

	// total voting power
	TotalVotingPower string `json:"total_voting_power,omitempty"`
}

// Validate validates this cosmos block sdk block evidence evidence items0 light client attack evidence
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidence) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateByzantineValidators(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConflictingBlock(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidence) validateByzantineValidators(formats strfmt.Registry) error {
	if swag.IsZero(m.ByzantineValidators) { // not required
		return nil
	}

	for i := 0; i < len(m.ByzantineValidators); i++ {
		if swag.IsZero(m.ByzantineValidators[i]) { // not required
			continue
		}

		if m.ByzantineValidators[i] != nil {
			if err := m.ByzantineValidators[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("light_client_attack_evidence" + "." + "byzantine_validators" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("light_client_attack_evidence" + "." + "byzantine_validators" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidence) validateConflictingBlock(formats strfmt.Registry) error {
	if swag.IsZero(m.ConflictingBlock) { // not required
		return nil
	}

	if m.ConflictingBlock != nil {
		if err := m.ConflictingBlock.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidence) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("light_client_attack_evidence"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cosmos block sdk block evidence evidence items0 light client attack evidence based on the context it is used
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidence) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateByzantineValidators(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConflictingBlock(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidence) contextValidateByzantineValidators(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ByzantineValidators); i++ {

		if m.ByzantineValidators[i] != nil {

			if swag.IsZero(m.ByzantineValidators[i]) { // not required
				return nil
			}

			if err := m.ByzantineValidators[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("light_client_attack_evidence" + "." + "byzantine_validators" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("light_client_attack_evidence" + "." + "byzantine_validators" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidence) contextValidateConflictingBlock(ctx context.Context, formats strfmt.Registry) error {

	if m.ConflictingBlock != nil {

		if swag.IsZero(m.ConflictingBlock) { // not required
			return nil
		}

		if err := m.ConflictingBlock.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidence) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidence) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidence
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0 cosmos block sdk block evidence evidence items0 light client attack evidence byzantine validators items0
//
// swagger:model CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0
type CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0 struct {

	// address
	// Format: byte
	Address strfmt.Base64 `json:"address,omitempty"`

	// proposer priority
	ProposerPriority string `json:"proposer_priority,omitempty"`

	// pub key
	PubKey *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey `json:"pub_key,omitempty"`

	// voting power
	VotingPower string `json:"voting_power,omitempty"`
}

// Validate validates this cosmos block sdk block evidence evidence items0 light client attack evidence byzantine validators items0
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePubKey(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0) validatePubKey(formats strfmt.Registry) error {
	if swag.IsZero(m.PubKey) { // not required
		return nil
	}

	if m.PubKey != nil {
		if err := m.PubKey.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pub_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("pub_key")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos block sdk block evidence evidence items0 light client attack evidence byzantine validators items0 based on the context it is used
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePubKey(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0) contextValidatePubKey(ctx context.Context, formats strfmt.Registry) error {

	if m.PubKey != nil {

		if swag.IsZero(m.PubKey) { // not required
			return nil
		}

		if err := m.PubKey.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pub_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("pub_key")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey cosmos block sdk block evidence evidence items0 light client attack evidence byzantine validators items0 pub key
//
// swagger:model CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey
type CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey struct {

	// ed25519
	// Format: byte
	Ed25519 strfmt.Base64 `json:"ed25519,omitempty"`

	// secp256k1
	// Format: byte
	Secp256k1 strfmt.Base64 `json:"secp256k1,omitempty"`
}

// Validate validates this cosmos block sdk block evidence evidence items0 light client attack evidence byzantine validators items0 pub key
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos block sdk block evidence evidence items0 light client attack evidence byzantine validators items0 pub key based on context it is used
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block
//
// swagger:model CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock
type CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock struct {

	// signed header
	SignedHeader *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader `json:"signed_header,omitempty"`

	// validator set
	ValidatorSet *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet `json:"validator_set,omitempty"`
}

// Validate validates this cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSignedHeader(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidatorSet(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) validateSignedHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.SignedHeader) { // not required
		return nil
	}

	if m.SignedHeader != nil {
		if err := m.SignedHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) validateValidatorSet(formats strfmt.Registry) error {
	if swag.IsZero(m.ValidatorSet) { // not required
		return nil
	}

	if m.ValidatorSet != nil {
		if err := m.ValidatorSet.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block based on the context it is used
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSignedHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateValidatorSet(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) contextValidateSignedHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.SignedHeader != nil {

		if swag.IsZero(m.SignedHeader) { // not required
			return nil
		}

		if err := m.SignedHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) contextValidateValidatorSet(ctx context.Context, formats strfmt.Registry) error {

	if m.ValidatorSet != nil {

		if swag.IsZero(m.ValidatorSet) { // not required
			return nil
		}

		if err := m.ValidatorSet.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block signed header
//
// swagger:model CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader
type CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader struct {

	// commit
	Commit *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit `json:"commit,omitempty"`

	// header
	Header *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader `json:"header,omitempty"`
}

// Validate validates this cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block signed header
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCommit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) validateCommit(formats strfmt.Registry) error {
	if swag.IsZero(m.Commit) { // not required
		return nil
	}

	if m.Commit != nil {
		if err := m.Commit.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) validateHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.Header) { // not required
		return nil
	}

	if m.Header != nil {
		if err := m.Header.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block signed header based on the context it is used
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCommit(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) contextValidateCommit(ctx context.Context, formats strfmt.Registry) error {

	if m.Commit != nil {

		if swag.IsZero(m.Commit) { // not required
			return nil
		}

		if err := m.Commit.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) contextValidateHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.Header != nil {

		if swag.IsZero(m.Header) { // not required
			return nil
		}

		if err := m.Header.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block signed header commit
//
// swagger:model CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit
type CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit struct {

	// block id
	BlockID *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID `json:"block_id,omitempty"`

	// height
	Height string `json:"height,omitempty"`

	// round
	Round int32 `json:"round,omitempty"`

	// signatures
	Signatures []*CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0 `json:"signatures"`
}

// Validate validates this cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block signed header commit
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSignatures(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) validateBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockID) { // not required
		return nil
	}

	if m.BlockID != nil {
		if err := m.BlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) validateSignatures(formats strfmt.Registry) error {
	if swag.IsZero(m.Signatures) { // not required
		return nil
	}

	for i := 0; i < len(m.Signatures); i++ {
		if swag.IsZero(m.Signatures[i]) { // not required
			continue
		}

		if m.Signatures[i] != nil {
			if err := m.Signatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "signatures" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "signatures" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block signed header commit based on the context it is used
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSignatures(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) contextValidateBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.BlockID != nil {

		if swag.IsZero(m.BlockID) { // not required
			return nil
		}

		if err := m.BlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) contextValidateSignatures(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Signatures); i++ {

		if m.Signatures[i] != nil {

			if swag.IsZero(m.Signatures[i]) { // not required
				return nil
			}

			if err := m.Signatures[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "signatures" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "signatures" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block signed header commit block ID
//
// swagger:model CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID
type CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block signed header commit block ID
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block signed header commit block ID based on the context it is used
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {

		if swag.IsZero(m.PartSetHeader) { // not required
			return nil
		}

		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block signed header commit block ID part set header
//
// swagger:model CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader
type CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block signed header commit block ID part set header
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block signed header commit block ID part set header based on context it is used
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0 cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block signed header commit signatures items0
//
// swagger:model CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0
type CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0 struct {

	// block id flag
	// Enum: ["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"]
	BlockIDFlag *string `json:"block_id_flag,omitempty"`

	// signature
	// Format: byte
	Signature strfmt.Base64 `json:"signature,omitempty"`

	// timestamp
	// Format: date-time
	Timestamp strfmt.DateTime `json:"timestamp,omitempty"`

	// validator address
	// Format: byte
	ValidatorAddress strfmt.Base64 `json:"validator_address,omitempty"`
}

// Validate validates this cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block signed header commit signatures items0
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockIDFlag(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var cosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0TypeBlockIDFlagPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		cosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0TypeBlockIDFlagPropEnum = append(cosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0TypeBlockIDFlagPropEnum, v)
	}
}

const (

	// CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGUNKNOWN captures enum value "BLOCK_ID_FLAG_UNKNOWN"
	CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGUNKNOWN string = "BLOCK_ID_FLAG_UNKNOWN"

	// CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGABSENT captures enum value "BLOCK_ID_FLAG_ABSENT"
	CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGABSENT string = "BLOCK_ID_FLAG_ABSENT"

	// CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGCOMMIT captures enum value "BLOCK_ID_FLAG_COMMIT"
	CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGCOMMIT string = "BLOCK_ID_FLAG_COMMIT"

	// CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGNIL captures enum value "BLOCK_ID_FLAG_NIL"
	CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGNIL string = "BLOCK_ID_FLAG_NIL"
)

// prop value enum
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) validateBlockIDFlagEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, cosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0TypeBlockIDFlagPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) validateBlockIDFlag(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockIDFlag) { // not required
		return nil
	}

	// value enum
	if err := m.validateBlockIDFlagEnum("block_id_flag", "body", *m.BlockIDFlag); err != nil {
		return err
	}

	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block signed header commit signatures items0 based on context it is used
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block signed header header
//
// swagger:model CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader
type CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader struct {

	// app hash
	// Format: byte
	AppHash strfmt.Base64 `json:"app_hash,omitempty"`

	// chain id
	ChainID string `json:"chain_id,omitempty"`

	// consensus hash
	// Format: byte
	ConsensusHash strfmt.Base64 `json:"consensus_hash,omitempty"`

	// data hash
	// Format: byte
	DataHash strfmt.Base64 `json:"data_hash,omitempty"`

	// evidence hash
	// Format: byte
	EvidenceHash strfmt.Base64 `json:"evidence_hash,omitempty"`

	// height
	Height string `json:"height,omitempty"`

	// last block id
	LastBlockID *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID `json:"last_block_id,omitempty"`

	// last commit hash
	// Format: byte
	LastCommitHash strfmt.Base64 `json:"last_commit_hash,omitempty"`

	// last results hash
	// Format: byte
	LastResultsHash strfmt.Base64 `json:"last_results_hash,omitempty"`

	// next validators hash
	// Format: byte
	NextValidatorsHash strfmt.Base64 `json:"next_validators_hash,omitempty"`

	// proposer address
	// Format: byte
	ProposerAddress strfmt.Base64 `json:"proposer_address,omitempty"`

	// time
	// Format: date-time
	Time strfmt.DateTime `json:"time,omitempty"`

	// validators hash
	// Format: byte
	ValidatorsHash strfmt.Base64 `json:"validators_hash,omitempty"`

	// version
	Version *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion `json:"version,omitempty"`
}

// Validate validates this cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block signed header header
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLastBlockID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) validateLastBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.LastBlockID) { // not required
		return nil
	}

	if m.LastBlockID != nil {
		if err := m.LastBlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) validateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.Time) { // not required
		return nil
	}

	if err := validate.FormatOf("light_client_attack_evidence"+"."+"conflicting_block"+"."+"signed_header"+"."+"header"+"."+"time", "body", "date-time", m.Time.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) validateVersion(formats strfmt.Registry) error {
	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if m.Version != nil {
		if err := m.Version.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "version")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "version")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block signed header header based on the context it is used
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLastBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) contextValidateLastBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.LastBlockID != nil {

		if swag.IsZero(m.LastBlockID) { // not required
			return nil
		}

		if err := m.LastBlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) contextValidateVersion(ctx context.Context, formats strfmt.Registry) error {

	if m.Version != nil {

		if swag.IsZero(m.Version) { // not required
			return nil
		}

		if err := m.Version.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "version")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "version")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block signed header header last block ID
//
// swagger:model CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID
type CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block signed header header last block ID
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block signed header header last block ID based on the context it is used
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {

		if swag.IsZero(m.PartSetHeader) { // not required
			return nil
		}

		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block signed header header last block ID part set header
//
// swagger:model CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader
type CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block signed header header last block ID part set header
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block signed header header last block ID part set header based on context it is used
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block signed header header version
//
// swagger:model CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion
type CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion struct {

	// app
	App string `json:"app,omitempty"`

	// block
	Block string `json:"block,omitempty"`
}

// Validate validates this cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block signed header header version
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block signed header header version based on context it is used
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block validator set
//
// swagger:model CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet
type CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet struct {

	// proposer
	Proposer *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer `json:"proposer,omitempty"`

	// total voting power
	TotalVotingPower string `json:"total_voting_power,omitempty"`

	// validators
	Validators []*CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0 `json:"validators"`
}

// Validate validates this cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block validator set
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateProposer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidators(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) validateProposer(formats strfmt.Registry) error {
	if swag.IsZero(m.Proposer) { // not required
		return nil
	}

	if m.Proposer != nil {
		if err := m.Proposer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) validateValidators(formats strfmt.Registry) error {
	if swag.IsZero(m.Validators) { // not required
		return nil
	}

	for i := 0; i < len(m.Validators); i++ {
		if swag.IsZero(m.Validators[i]) { // not required
			continue
		}

		if m.Validators[i] != nil {
			if err := m.Validators[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "validators" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "validators" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block validator set based on the context it is used
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateProposer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateValidators(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) contextValidateProposer(ctx context.Context, formats strfmt.Registry) error {

	if m.Proposer != nil {

		if swag.IsZero(m.Proposer) { // not required
			return nil
		}

		if err := m.Proposer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) contextValidateValidators(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Validators); i++ {

		if m.Validators[i] != nil {

			if swag.IsZero(m.Validators[i]) { // not required
				return nil
			}

			if err := m.Validators[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "validators" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "validators" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block validator set proposer
//
// swagger:model CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer
type CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer struct {

	// address
	// Format: byte
	Address strfmt.Base64 `json:"address,omitempty"`

	// proposer priority
	ProposerPriority string `json:"proposer_priority,omitempty"`

	// pub key
	PubKey *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey `json:"pub_key,omitempty"`

	// voting power
	VotingPower string `json:"voting_power,omitempty"`
}

// Validate validates this cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block validator set proposer
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePubKey(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer) validatePubKey(formats strfmt.Registry) error {
	if swag.IsZero(m.PubKey) { // not required
		return nil
	}

	if m.PubKey != nil {
		if err := m.PubKey.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer" + "." + "pub_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer" + "." + "pub_key")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block validator set proposer based on the context it is used
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePubKey(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer) contextValidatePubKey(ctx context.Context, formats strfmt.Registry) error {

	if m.PubKey != nil {

		if swag.IsZero(m.PubKey) { // not required
			return nil
		}

		if err := m.PubKey.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer" + "." + "pub_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer" + "." + "pub_key")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block validator set proposer pub key
//
// swagger:model CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey
type CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey struct {

	// ed25519
	// Format: byte
	Ed25519 strfmt.Base64 `json:"ed25519,omitempty"`

	// secp256k1
	// Format: byte
	Secp256k1 strfmt.Base64 `json:"secp256k1,omitempty"`
}

// Validate validates this cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block validator set proposer pub key
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block validator set proposer pub key based on context it is used
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0 cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block validator set validators items0
//
// swagger:model CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0
type CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0 struct {

	// address
	// Format: byte
	Address strfmt.Base64 `json:"address,omitempty"`

	// proposer priority
	ProposerPriority string `json:"proposer_priority,omitempty"`

	// pub key
	PubKey *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey `json:"pub_key,omitempty"`

	// voting power
	VotingPower string `json:"voting_power,omitempty"`
}

// Validate validates this cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block validator set validators items0
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePubKey(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0) validatePubKey(formats strfmt.Registry) error {
	if swag.IsZero(m.PubKey) { // not required
		return nil
	}

	if m.PubKey != nil {
		if err := m.PubKey.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pub_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("pub_key")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block validator set validators items0 based on the context it is used
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePubKey(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0) contextValidatePubKey(ctx context.Context, formats strfmt.Registry) error {

	if m.PubKey != nil {

		if swag.IsZero(m.PubKey) { // not required
			return nil
		}

		if err := m.PubKey.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pub_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("pub_key")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block validator set validators items0 pub key
//
// swagger:model CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey
type CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey struct {

	// ed25519
	// Format: byte
	Ed25519 strfmt.Base64 `json:"ed25519,omitempty"`

	// secp256k1
	// Format: byte
	Secp256k1 strfmt.Base64 `json:"secp256k1,omitempty"`
}

// Validate validates this cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block validator set validators items0 pub key
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos block sdk block evidence evidence items0 light client attack evidence conflicting block validator set validators items0 pub key based on context it is used
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlockHeader cosmos block sdk block header
//
// swagger:model CosmosBlockSdkBlockHeader
type CosmosBlockSdkBlockHeader struct {

	// app hash
	// Format: byte
	AppHash strfmt.Base64 `json:"app_hash,omitempty"`

	// chain id
	ChainID string `json:"chain_id,omitempty"`

	// consensus hash
	// Format: byte
	ConsensusHash strfmt.Base64 `json:"consensus_hash,omitempty"`

	// data hash
	// Format: byte
	DataHash strfmt.Base64 `json:"data_hash,omitempty"`

	// evidence hash
	// Format: byte
	EvidenceHash strfmt.Base64 `json:"evidence_hash,omitempty"`

	// height
	Height string `json:"height,omitempty"`

	// last block id
	LastBlockID *CosmosBlockSdkBlockHeaderLastBlockID `json:"last_block_id,omitempty"`

	// last commit hash
	// Format: byte
	LastCommitHash strfmt.Base64 `json:"last_commit_hash,omitempty"`

	// last results hash
	// Format: byte
	LastResultsHash strfmt.Base64 `json:"last_results_hash,omitempty"`

	// next validators hash
	// Format: byte
	NextValidatorsHash strfmt.Base64 `json:"next_validators_hash,omitempty"`

	// proposer address
	ProposerAddress string `json:"proposer_address,omitempty"`

	// time
	// Format: date-time
	Time strfmt.DateTime `json:"time,omitempty"`

	// validators hash
	// Format: byte
	ValidatorsHash strfmt.Base64 `json:"validators_hash,omitempty"`

	// version
	Version *CosmosBlockSdkBlockHeaderVersion `json:"version,omitempty"`
}

// Validate validates this cosmos block sdk block header
func (m *CosmosBlockSdkBlockHeader) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLastBlockID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockHeader) validateLastBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.LastBlockID) { // not required
		return nil
	}

	if m.LastBlockID != nil {
		if err := m.LastBlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sdk_block" + "." + "header" + "." + "last_block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sdk_block" + "." + "header" + "." + "last_block_id")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockSdkBlockHeader) validateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.Time) { // not required
		return nil
	}

	if err := validate.FormatOf("sdk_block"+"."+"header"+"."+"time", "body", "date-time", m.Time.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *CosmosBlockSdkBlockHeader) validateVersion(formats strfmt.Registry) error {
	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if m.Version != nil {
		if err := m.Version.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sdk_block" + "." + "header" + "." + "version")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sdk_block" + "." + "header" + "." + "version")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos block sdk block header based on the context it is used
func (m *CosmosBlockSdkBlockHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLastBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockHeader) contextValidateLastBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.LastBlockID != nil {

		if swag.IsZero(m.LastBlockID) { // not required
			return nil
		}

		if err := m.LastBlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sdk_block" + "." + "header" + "." + "last_block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sdk_block" + "." + "header" + "." + "last_block_id")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockSdkBlockHeader) contextValidateVersion(ctx context.Context, formats strfmt.Registry) error {

	if m.Version != nil {

		if swag.IsZero(m.Version) { // not required
			return nil
		}

		if err := m.Version.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sdk_block" + "." + "header" + "." + "version")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sdk_block" + "." + "header" + "." + "version")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlockHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlockHeader) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlockHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlockHeaderLastBlockID cosmos block sdk block header last block ID
//
// swagger:model CosmosBlockSdkBlockHeaderLastBlockID
type CosmosBlockSdkBlockHeaderLastBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *CosmosBlockSdkBlockHeaderLastBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this cosmos block sdk block header last block ID
func (m *CosmosBlockSdkBlockHeaderLastBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockHeaderLastBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sdk_block" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sdk_block" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos block sdk block header last block ID based on the context it is used
func (m *CosmosBlockSdkBlockHeaderLastBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockHeaderLastBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {

		if swag.IsZero(m.PartSetHeader) { // not required
			return nil
		}

		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sdk_block" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sdk_block" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlockHeaderLastBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlockHeaderLastBlockID) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlockHeaderLastBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlockHeaderLastBlockIDPartSetHeader cosmos block sdk block header last block ID part set header
//
// swagger:model CosmosBlockSdkBlockHeaderLastBlockIDPartSetHeader
type CosmosBlockSdkBlockHeaderLastBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this cosmos block sdk block header last block ID part set header
func (m *CosmosBlockSdkBlockHeaderLastBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos block sdk block header last block ID part set header based on context it is used
func (m *CosmosBlockSdkBlockHeaderLastBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlockHeaderLastBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlockHeaderLastBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlockHeaderLastBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlockHeaderVersion cosmos block sdk block header version
//
// swagger:model CosmosBlockSdkBlockHeaderVersion
type CosmosBlockSdkBlockHeaderVersion struct {

	// app
	App string `json:"app,omitempty"`

	// block
	Block string `json:"block,omitempty"`
}

// Validate validates this cosmos block sdk block header version
func (m *CosmosBlockSdkBlockHeaderVersion) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos block sdk block header version based on context it is used
func (m *CosmosBlockSdkBlockHeaderVersion) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlockHeaderVersion) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlockHeaderVersion) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlockHeaderVersion
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlockLastCommit cosmos block sdk block last commit
//
// swagger:model CosmosBlockSdkBlockLastCommit
type CosmosBlockSdkBlockLastCommit struct {

	// block id
	BlockID *CosmosBlockSdkBlockLastCommitBlockID `json:"block_id,omitempty"`

	// height
	Height string `json:"height,omitempty"`

	// round
	Round int32 `json:"round,omitempty"`

	// signatures
	Signatures []*CosmosBlockSdkBlockLastCommitSignaturesItems0 `json:"signatures"`
}

// Validate validates this cosmos block sdk block last commit
func (m *CosmosBlockSdkBlockLastCommit) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSignatures(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockLastCommit) validateBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockID) { // not required
		return nil
	}

	if m.BlockID != nil {
		if err := m.BlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sdk_block" + "." + "last_commit" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sdk_block" + "." + "last_commit" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockSdkBlockLastCommit) validateSignatures(formats strfmt.Registry) error {
	if swag.IsZero(m.Signatures) { // not required
		return nil
	}

	for i := 0; i < len(m.Signatures); i++ {
		if swag.IsZero(m.Signatures[i]) { // not required
			continue
		}

		if m.Signatures[i] != nil {
			if err := m.Signatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("sdk_block" + "." + "last_commit" + "." + "signatures" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("sdk_block" + "." + "last_commit" + "." + "signatures" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this cosmos block sdk block last commit based on the context it is used
func (m *CosmosBlockSdkBlockLastCommit) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSignatures(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockLastCommit) contextValidateBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.BlockID != nil {

		if swag.IsZero(m.BlockID) { // not required
			return nil
		}

		if err := m.BlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sdk_block" + "." + "last_commit" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sdk_block" + "." + "last_commit" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

func (m *CosmosBlockSdkBlockLastCommit) contextValidateSignatures(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Signatures); i++ {

		if m.Signatures[i] != nil {

			if swag.IsZero(m.Signatures[i]) { // not required
				return nil
			}

			if err := m.Signatures[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("sdk_block" + "." + "last_commit" + "." + "signatures" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("sdk_block" + "." + "last_commit" + "." + "signatures" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlockLastCommit) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlockLastCommit) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlockLastCommit
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlockLastCommitBlockID cosmos block sdk block last commit block ID
//
// swagger:model CosmosBlockSdkBlockLastCommitBlockID
type CosmosBlockSdkBlockLastCommitBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *CosmosBlockSdkBlockLastCommitBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this cosmos block sdk block last commit block ID
func (m *CosmosBlockSdkBlockLastCommitBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockLastCommitBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sdk_block" + "." + "last_commit" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sdk_block" + "." + "last_commit" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this cosmos block sdk block last commit block ID based on the context it is used
func (m *CosmosBlockSdkBlockLastCommitBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosmosBlockSdkBlockLastCommitBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {

		if swag.IsZero(m.PartSetHeader) { // not required
			return nil
		}

		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sdk_block" + "." + "last_commit" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("sdk_block" + "." + "last_commit" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlockLastCommitBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlockLastCommitBlockID) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlockLastCommitBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlockLastCommitBlockIDPartSetHeader cosmos block sdk block last commit block ID part set header
//
// swagger:model CosmosBlockSdkBlockLastCommitBlockIDPartSetHeader
type CosmosBlockSdkBlockLastCommitBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this cosmos block sdk block last commit block ID part set header
func (m *CosmosBlockSdkBlockLastCommitBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this cosmos block sdk block last commit block ID part set header based on context it is used
func (m *CosmosBlockSdkBlockLastCommitBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlockLastCommitBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlockLastCommitBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlockLastCommitBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CosmosBlockSdkBlockLastCommitSignaturesItems0 cosmos block sdk block last commit signatures items0
//
// swagger:model CosmosBlockSdkBlockLastCommitSignaturesItems0
type CosmosBlockSdkBlockLastCommitSignaturesItems0 struct {

	// block id flag
	// Enum: ["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"]
	BlockIDFlag *string `json:"block_id_flag,omitempty"`

	// signature
	// Format: byte
	Signature strfmt.Base64 `json:"signature,omitempty"`

	// timestamp
	// Format: date-time
	Timestamp strfmt.DateTime `json:"timestamp,omitempty"`

	// validator address
	// Format: byte
	ValidatorAddress strfmt.Base64 `json:"validator_address,omitempty"`
}

// Validate validates this cosmos block sdk block last commit signatures items0
func (m *CosmosBlockSdkBlockLastCommitSignaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockIDFlag(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var cosmosBlockSdkBlockLastCommitSignaturesItems0TypeBlockIDFlagPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		cosmosBlockSdkBlockLastCommitSignaturesItems0TypeBlockIDFlagPropEnum = append(cosmosBlockSdkBlockLastCommitSignaturesItems0TypeBlockIDFlagPropEnum, v)
	}
}

const (

	// CosmosBlockSdkBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGUNKNOWN captures enum value "BLOCK_ID_FLAG_UNKNOWN"
	CosmosBlockSdkBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGUNKNOWN string = "BLOCK_ID_FLAG_UNKNOWN"

	// CosmosBlockSdkBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGABSENT captures enum value "BLOCK_ID_FLAG_ABSENT"
	CosmosBlockSdkBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGABSENT string = "BLOCK_ID_FLAG_ABSENT"

	// CosmosBlockSdkBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGCOMMIT captures enum value "BLOCK_ID_FLAG_COMMIT"
	CosmosBlockSdkBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGCOMMIT string = "BLOCK_ID_FLAG_COMMIT"

	// CosmosBlockSdkBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGNIL captures enum value "BLOCK_ID_FLAG_NIL"
	CosmosBlockSdkBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGNIL string = "BLOCK_ID_FLAG_NIL"
)

// prop value enum
func (m *CosmosBlockSdkBlockLastCommitSignaturesItems0) validateBlockIDFlagEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, cosmosBlockSdkBlockLastCommitSignaturesItems0TypeBlockIDFlagPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CosmosBlockSdkBlockLastCommitSignaturesItems0) validateBlockIDFlag(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockIDFlag) { // not required
		return nil
	}

	// value enum
	if err := m.validateBlockIDFlagEnum("block_id_flag", "body", *m.BlockIDFlag); err != nil {
		return err
	}

	return nil
}

func (m *CosmosBlockSdkBlockLastCommitSignaturesItems0) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this cosmos block sdk block last commit signatures items0 based on context it is used
func (m *CosmosBlockSdkBlockLastCommitSignaturesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CosmosBlockSdkBlockLastCommitSignaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosmosBlockSdkBlockLastCommitSignaturesItems0) UnmarshalBinary(b []byte) error {
	var res CosmosBlockSdkBlockLastCommitSignaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
