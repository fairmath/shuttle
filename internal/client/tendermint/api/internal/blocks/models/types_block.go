// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// TypesBlock types block
//
// swagger:model types.Block
type TypesBlock struct {

	// data
	Data *TypesBlockData `json:"data,omitempty"`

	// evidence
	Evidence *TypesBlockEvidence `json:"evidence,omitempty"`

	// header
	Header *TypesBlockHeader `json:"header,omitempty"`

	// last commit
	LastCommit *TypesBlockLastCommit `json:"last_commit,omitempty"`
}

// Validate validates this types block
func (m *TypesBlock) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateData(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEvidence(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHeader(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastCommit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlock) validateData(formats strfmt.Registry) error {
	if swag.IsZero(m.Data) { // not required
		return nil
	}

	if m.Data != nil {
		if err := m.Data.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("data")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("data")
			}
			return err
		}
	}

	return nil
}

func (m *TypesBlock) validateEvidence(formats strfmt.Registry) error {
	if swag.IsZero(m.Evidence) { // not required
		return nil
	}

	if m.Evidence != nil {
		if err := m.Evidence.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("evidence")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("evidence")
			}
			return err
		}
	}

	return nil
}

func (m *TypesBlock) validateHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.Header) { // not required
		return nil
	}

	if m.Header != nil {
		if err := m.Header.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("header")
			}
			return err
		}
	}

	return nil
}

func (m *TypesBlock) validateLastCommit(formats strfmt.Registry) error {
	if swag.IsZero(m.LastCommit) { // not required
		return nil
	}

	if m.LastCommit != nil {
		if err := m.LastCommit.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("last_commit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("last_commit")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this types block based on the context it is used
func (m *TypesBlock) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateData(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEvidence(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLastCommit(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlock) contextValidateData(ctx context.Context, formats strfmt.Registry) error {

	if m.Data != nil {

		if swag.IsZero(m.Data) { // not required
			return nil
		}

		if err := m.Data.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("data")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("data")
			}
			return err
		}
	}

	return nil
}

func (m *TypesBlock) contextValidateEvidence(ctx context.Context, formats strfmt.Registry) error {

	if m.Evidence != nil {

		if swag.IsZero(m.Evidence) { // not required
			return nil
		}

		if err := m.Evidence.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("evidence")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("evidence")
			}
			return err
		}
	}

	return nil
}

func (m *TypesBlock) contextValidateHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.Header != nil {

		if swag.IsZero(m.Header) { // not required
			return nil
		}

		if err := m.Header.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("header")
			}
			return err
		}
	}

	return nil
}

func (m *TypesBlock) contextValidateLastCommit(ctx context.Context, formats strfmt.Registry) error {

	if m.LastCommit != nil {

		if swag.IsZero(m.LastCommit) { // not required
			return nil
		}

		if err := m.LastCommit.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("last_commit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("last_commit")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlock) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlock) UnmarshalBinary(b []byte) error {
	var res TypesBlock
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TypesBlockData types block data
//
// swagger:model TypesBlockData
type TypesBlockData struct {

	// txs
	Txs []strfmt.Base64 `json:"txs"`
}

// Validate validates this types block data
func (m *TypesBlockData) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this types block data based on context it is used
func (m *TypesBlockData) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlockData) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlockData) UnmarshalBinary(b []byte) error {
	var res TypesBlockData
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TypesBlockEvidence types block evidence
//
// swagger:model TypesBlockEvidence
type TypesBlockEvidence struct {

	// evidence
	Evidence []*TypesBlockEvidenceEvidenceItems0 `json:"evidence"`
}

// Validate validates this types block evidence
func (m *TypesBlockEvidence) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEvidence(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockEvidence) validateEvidence(formats strfmt.Registry) error {
	if swag.IsZero(m.Evidence) { // not required
		return nil
	}

	for i := 0; i < len(m.Evidence); i++ {
		if swag.IsZero(m.Evidence[i]) { // not required
			continue
		}

		if m.Evidence[i] != nil {
			if err := m.Evidence[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("evidence" + "." + "evidence" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("evidence" + "." + "evidence" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this types block evidence based on the context it is used
func (m *TypesBlockEvidence) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateEvidence(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockEvidence) contextValidateEvidence(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Evidence); i++ {

		if m.Evidence[i] != nil {

			if swag.IsZero(m.Evidence[i]) { // not required
				return nil
			}

			if err := m.Evidence[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("evidence" + "." + "evidence" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("evidence" + "." + "evidence" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlockEvidence) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlockEvidence) UnmarshalBinary(b []byte) error {
	var res TypesBlockEvidence
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TypesBlockEvidenceEvidenceItems0 types block evidence evidence items0
//
// swagger:model TypesBlockEvidenceEvidenceItems0
type TypesBlockEvidenceEvidenceItems0 struct {

	// duplicate vote evidence
	DuplicateVoteEvidence *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidence `json:"duplicate_vote_evidence,omitempty"`

	// light client attack evidence
	LightClientAttackEvidence *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidence `json:"light_client_attack_evidence,omitempty"`
}

// Validate validates this types block evidence evidence items0
func (m *TypesBlockEvidenceEvidenceItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDuplicateVoteEvidence(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLightClientAttackEvidence(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0) validateDuplicateVoteEvidence(formats strfmt.Registry) error {
	if swag.IsZero(m.DuplicateVoteEvidence) { // not required
		return nil
	}

	if m.DuplicateVoteEvidence != nil {
		if err := m.DuplicateVoteEvidence.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence")
			}
			return err
		}
	}

	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0) validateLightClientAttackEvidence(formats strfmt.Registry) error {
	if swag.IsZero(m.LightClientAttackEvidence) { // not required
		return nil
	}

	if m.LightClientAttackEvidence != nil {
		if err := m.LightClientAttackEvidence.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this types block evidence evidence items0 based on the context it is used
func (m *TypesBlockEvidenceEvidenceItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDuplicateVoteEvidence(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLightClientAttackEvidence(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0) contextValidateDuplicateVoteEvidence(ctx context.Context, formats strfmt.Registry) error {

	if m.DuplicateVoteEvidence != nil {

		if swag.IsZero(m.DuplicateVoteEvidence) { // not required
			return nil
		}

		if err := m.DuplicateVoteEvidence.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence")
			}
			return err
		}
	}

	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0) contextValidateLightClientAttackEvidence(ctx context.Context, formats strfmt.Registry) error {

	if m.LightClientAttackEvidence != nil {

		if swag.IsZero(m.LightClientAttackEvidence) { // not required
			return nil
		}

		if err := m.LightClientAttackEvidence.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0) UnmarshalBinary(b []byte) error {
	var res TypesBlockEvidenceEvidenceItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidence types block evidence evidence items0 duplicate vote evidence
//
// swagger:model TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidence
type TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidence struct {

	// timestamp
	// Format: date-time
	Timestamp strfmt.DateTime `json:"timestamp,omitempty"`

	// total voting power
	TotalVotingPower string `json:"total_voting_power,omitempty"`

	// validator power
	ValidatorPower string `json:"validator_power,omitempty"`

	// vote a
	Votea *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea `json:"vote_a,omitempty"`

	// vote b
	Voteb *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb `json:"vote_b,omitempty"`
}

// Validate validates this types block evidence evidence items0 duplicate vote evidence
func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidence) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVotea(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVoteb(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidence) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("duplicate_vote_evidence"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidence) validateVotea(formats strfmt.Registry) error {
	if swag.IsZero(m.Votea) { // not required
		return nil
	}

	if m.Votea != nil {
		if err := m.Votea.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_a")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_a")
			}
			return err
		}
	}

	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidence) validateVoteb(formats strfmt.Registry) error {
	if swag.IsZero(m.Voteb) { // not required
		return nil
	}

	if m.Voteb != nil {
		if err := m.Voteb.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_b")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_b")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this types block evidence evidence items0 duplicate vote evidence based on the context it is used
func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidence) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateVotea(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVoteb(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidence) contextValidateVotea(ctx context.Context, formats strfmt.Registry) error {

	if m.Votea != nil {

		if swag.IsZero(m.Votea) { // not required
			return nil
		}

		if err := m.Votea.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_a")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_a")
			}
			return err
		}
	}

	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidence) contextValidateVoteb(ctx context.Context, formats strfmt.Registry) error {

	if m.Voteb != nil {

		if swag.IsZero(m.Voteb) { // not required
			return nil
		}

		if err := m.Voteb.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_b")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_b")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidence) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidence) UnmarshalBinary(b []byte) error {
	var res TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidence
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea types block evidence evidence items0 duplicate vote evidence votea
//
// swagger:model TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea
type TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea struct {

	// block id
	BlockID *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID `json:"block_id,omitempty"`

	// extension
	// Format: byte
	Extension strfmt.Base64 `json:"extension,omitempty"`

	// extension signature
	// Format: byte
	ExtensionSignature strfmt.Base64 `json:"extension_signature,omitempty"`

	// height
	Height string `json:"height,omitempty"`

	// round
	Round int32 `json:"round,omitempty"`

	// signature
	// Format: byte
	Signature strfmt.Base64 `json:"signature,omitempty"`

	// timestamp
	// Format: date-time
	Timestamp strfmt.DateTime `json:"timestamp,omitempty"`

	// type
	// Enum: ["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"]
	Type *string `json:"type,omitempty"`

	// validator address
	// Format: byte
	ValidatorAddress strfmt.Base64 `json:"validator_address,omitempty"`

	// validator index
	ValidatorIndex int32 `json:"validator_index,omitempty"`
}

// Validate validates this types block evidence evidence items0 duplicate vote evidence votea
func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) validateBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockID) { // not required
		return nil
	}

	if m.BlockID != nil {
		if err := m.BlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("duplicate_vote_evidence"+"."+"vote_a"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

var typesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		typesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeTypePropEnum = append(typesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeTypePropEnum, v)
	}
}

const (

	// TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEUNKNOWN captures enum value "SIGNED_MSG_TYPE_UNKNOWN"
	TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEUNKNOWN string = "SIGNED_MSG_TYPE_UNKNOWN"

	// TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEPREVOTE captures enum value "SIGNED_MSG_TYPE_PREVOTE"
	TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEPREVOTE string = "SIGNED_MSG_TYPE_PREVOTE"

	// TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEPRECOMMIT captures enum value "SIGNED_MSG_TYPE_PRECOMMIT"
	TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEPRECOMMIT string = "SIGNED_MSG_TYPE_PRECOMMIT"

	// TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEPROPOSAL captures enum value "SIGNED_MSG_TYPE_PROPOSAL"
	TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEPROPOSAL string = "SIGNED_MSG_TYPE_PROPOSAL"
)

// prop value enum
func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, typesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("duplicate_vote_evidence"+"."+"vote_a"+"."+"type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this types block evidence evidence items0 duplicate vote evidence votea based on the context it is used
func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) contextValidateBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.BlockID != nil {

		if swag.IsZero(m.BlockID) { // not required
			return nil
		}

		if err := m.BlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) UnmarshalBinary(b []byte) error {
	var res TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID types block evidence evidence items0 duplicate vote evidence votea block ID
//
// swagger:model TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID
type TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this types block evidence evidence items0 duplicate vote evidence votea block ID
func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this types block evidence evidence items0 duplicate vote evidence votea block ID based on the context it is used
func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {

		if swag.IsZero(m.PartSetHeader) { // not required
			return nil
		}

		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID) UnmarshalBinary(b []byte) error {
	var res TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader types block evidence evidence items0 duplicate vote evidence votea block ID part set header
//
// swagger:model TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader
type TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this types block evidence evidence items0 duplicate vote evidence votea block ID part set header
func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this types block evidence evidence items0 duplicate vote evidence votea block ID part set header based on context it is used
func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb types block evidence evidence items0 duplicate vote evidence voteb
//
// swagger:model TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb
type TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb struct {

	// block id
	BlockID *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID `json:"block_id,omitempty"`

	// extension
	// Format: byte
	Extension strfmt.Base64 `json:"extension,omitempty"`

	// extension signature
	// Format: byte
	ExtensionSignature strfmt.Base64 `json:"extension_signature,omitempty"`

	// height
	Height string `json:"height,omitempty"`

	// round
	Round int32 `json:"round,omitempty"`

	// signature
	// Format: byte
	Signature strfmt.Base64 `json:"signature,omitempty"`

	// timestamp
	// Format: date-time
	Timestamp strfmt.DateTime `json:"timestamp,omitempty"`

	// type
	// Enum: ["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"]
	Type *string `json:"type,omitempty"`

	// validator address
	// Format: byte
	ValidatorAddress strfmt.Base64 `json:"validator_address,omitempty"`

	// validator index
	ValidatorIndex int32 `json:"validator_index,omitempty"`
}

// Validate validates this types block evidence evidence items0 duplicate vote evidence voteb
func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) validateBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockID) { // not required
		return nil
	}

	if m.BlockID != nil {
		if err := m.BlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("duplicate_vote_evidence"+"."+"vote_b"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

var typesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		typesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeTypePropEnum = append(typesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeTypePropEnum, v)
	}
}

const (

	// TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEUNKNOWN captures enum value "SIGNED_MSG_TYPE_UNKNOWN"
	TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEUNKNOWN string = "SIGNED_MSG_TYPE_UNKNOWN"

	// TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEPREVOTE captures enum value "SIGNED_MSG_TYPE_PREVOTE"
	TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEPREVOTE string = "SIGNED_MSG_TYPE_PREVOTE"

	// TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEPRECOMMIT captures enum value "SIGNED_MSG_TYPE_PRECOMMIT"
	TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEPRECOMMIT string = "SIGNED_MSG_TYPE_PRECOMMIT"

	// TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEPROPOSAL captures enum value "SIGNED_MSG_TYPE_PROPOSAL"
	TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEPROPOSAL string = "SIGNED_MSG_TYPE_PROPOSAL"
)

// prop value enum
func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, typesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("duplicate_vote_evidence"+"."+"vote_b"+"."+"type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this types block evidence evidence items0 duplicate vote evidence voteb based on the context it is used
func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) contextValidateBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.BlockID != nil {

		if swag.IsZero(m.BlockID) { // not required
			return nil
		}

		if err := m.BlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) UnmarshalBinary(b []byte) error {
	var res TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID types block evidence evidence items0 duplicate vote evidence voteb block ID
//
// swagger:model TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID
type TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this types block evidence evidence items0 duplicate vote evidence voteb block ID
func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this types block evidence evidence items0 duplicate vote evidence voteb block ID based on the context it is used
func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {

		if swag.IsZero(m.PartSetHeader) { // not required
			return nil
		}

		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID) UnmarshalBinary(b []byte) error {
	var res TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader types block evidence evidence items0 duplicate vote evidence voteb block ID part set header
//
// swagger:model TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader
type TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this types block evidence evidence items0 duplicate vote evidence voteb block ID part set header
func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this types block evidence evidence items0 duplicate vote evidence voteb block ID part set header based on context it is used
func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res TypesBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TypesBlockEvidenceEvidenceItems0LightClientAttackEvidence types block evidence evidence items0 light client attack evidence
//
// swagger:model TypesBlockEvidenceEvidenceItems0LightClientAttackEvidence
type TypesBlockEvidenceEvidenceItems0LightClientAttackEvidence struct {

	// byzantine validators
	ByzantineValidators []*TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0 `json:"byzantine_validators"`

	// common height
	CommonHeight string `json:"common_height,omitempty"`

	// conflicting block
	ConflictingBlock *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock `json:"conflicting_block,omitempty"`

	// timestamp
	// Format: date-time
	Timestamp strfmt.DateTime `json:"timestamp,omitempty"`

	// total voting power
	TotalVotingPower string `json:"total_voting_power,omitempty"`
}

// Validate validates this types block evidence evidence items0 light client attack evidence
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidence) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateByzantineValidators(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConflictingBlock(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidence) validateByzantineValidators(formats strfmt.Registry) error {
	if swag.IsZero(m.ByzantineValidators) { // not required
		return nil
	}

	for i := 0; i < len(m.ByzantineValidators); i++ {
		if swag.IsZero(m.ByzantineValidators[i]) { // not required
			continue
		}

		if m.ByzantineValidators[i] != nil {
			if err := m.ByzantineValidators[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("light_client_attack_evidence" + "." + "byzantine_validators" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("light_client_attack_evidence" + "." + "byzantine_validators" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidence) validateConflictingBlock(formats strfmt.Registry) error {
	if swag.IsZero(m.ConflictingBlock) { // not required
		return nil
	}

	if m.ConflictingBlock != nil {
		if err := m.ConflictingBlock.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block")
			}
			return err
		}
	}

	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidence) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("light_client_attack_evidence"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this types block evidence evidence items0 light client attack evidence based on the context it is used
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidence) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateByzantineValidators(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConflictingBlock(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidence) contextValidateByzantineValidators(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ByzantineValidators); i++ {

		if m.ByzantineValidators[i] != nil {

			if swag.IsZero(m.ByzantineValidators[i]) { // not required
				return nil
			}

			if err := m.ByzantineValidators[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("light_client_attack_evidence" + "." + "byzantine_validators" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("light_client_attack_evidence" + "." + "byzantine_validators" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidence) contextValidateConflictingBlock(ctx context.Context, formats strfmt.Registry) error {

	if m.ConflictingBlock != nil {

		if swag.IsZero(m.ConflictingBlock) { // not required
			return nil
		}

		if err := m.ConflictingBlock.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidence) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidence) UnmarshalBinary(b []byte) error {
	var res TypesBlockEvidenceEvidenceItems0LightClientAttackEvidence
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0 types block evidence evidence items0 light client attack evidence byzantine validators items0
//
// swagger:model TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0
type TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0 struct {

	// address
	// Format: byte
	Address strfmt.Base64 `json:"address,omitempty"`

	// proposer priority
	ProposerPriority string `json:"proposer_priority,omitempty"`

	// pub key
	PubKey *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey `json:"pub_key,omitempty"`

	// voting power
	VotingPower string `json:"voting_power,omitempty"`
}

// Validate validates this types block evidence evidence items0 light client attack evidence byzantine validators items0
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePubKey(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0) validatePubKey(formats strfmt.Registry) error {
	if swag.IsZero(m.PubKey) { // not required
		return nil
	}

	if m.PubKey != nil {
		if err := m.PubKey.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pub_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("pub_key")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this types block evidence evidence items0 light client attack evidence byzantine validators items0 based on the context it is used
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePubKey(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0) contextValidatePubKey(ctx context.Context, formats strfmt.Registry) error {

	if m.PubKey != nil {

		if swag.IsZero(m.PubKey) { // not required
			return nil
		}

		if err := m.PubKey.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pub_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("pub_key")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0) UnmarshalBinary(b []byte) error {
	var res TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey types block evidence evidence items0 light client attack evidence byzantine validators items0 pub key
//
// swagger:model TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey
type TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey struct {

	// ed25519
	// Format: byte
	Ed25519 strfmt.Base64 `json:"ed25519,omitempty"`

	// secp256k1
	// Format: byte
	Secp256k1 strfmt.Base64 `json:"secp256k1,omitempty"`
}

// Validate validates this types block evidence evidence items0 light client attack evidence byzantine validators items0 pub key
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this types block evidence evidence items0 light client attack evidence byzantine validators items0 pub key based on context it is used
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey) UnmarshalBinary(b []byte) error {
	var res TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock types block evidence evidence items0 light client attack evidence conflicting block
//
// swagger:model TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock
type TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock struct {

	// signed header
	SignedHeader *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader `json:"signed_header,omitempty"`

	// validator set
	ValidatorSet *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet `json:"validator_set,omitempty"`
}

// Validate validates this types block evidence evidence items0 light client attack evidence conflicting block
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSignedHeader(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidatorSet(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) validateSignedHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.SignedHeader) { // not required
		return nil
	}

	if m.SignedHeader != nil {
		if err := m.SignedHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header")
			}
			return err
		}
	}

	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) validateValidatorSet(formats strfmt.Registry) error {
	if swag.IsZero(m.ValidatorSet) { // not required
		return nil
	}

	if m.ValidatorSet != nil {
		if err := m.ValidatorSet.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this types block evidence evidence items0 light client attack evidence conflicting block based on the context it is used
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSignedHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateValidatorSet(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) contextValidateSignedHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.SignedHeader != nil {

		if swag.IsZero(m.SignedHeader) { // not required
			return nil
		}

		if err := m.SignedHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header")
			}
			return err
		}
	}

	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) contextValidateValidatorSet(ctx context.Context, formats strfmt.Registry) error {

	if m.ValidatorSet != nil {

		if swag.IsZero(m.ValidatorSet) { // not required
			return nil
		}

		if err := m.ValidatorSet.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) UnmarshalBinary(b []byte) error {
	var res TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader types block evidence evidence items0 light client attack evidence conflicting block signed header
//
// swagger:model TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader
type TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader struct {

	// commit
	Commit *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit `json:"commit,omitempty"`

	// header
	Header *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader `json:"header,omitempty"`
}

// Validate validates this types block evidence evidence items0 light client attack evidence conflicting block signed header
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCommit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) validateCommit(formats strfmt.Registry) error {
	if swag.IsZero(m.Commit) { // not required
		return nil
	}

	if m.Commit != nil {
		if err := m.Commit.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit")
			}
			return err
		}
	}

	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) validateHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.Header) { // not required
		return nil
	}

	if m.Header != nil {
		if err := m.Header.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this types block evidence evidence items0 light client attack evidence conflicting block signed header based on the context it is used
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCommit(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) contextValidateCommit(ctx context.Context, formats strfmt.Registry) error {

	if m.Commit != nil {

		if swag.IsZero(m.Commit) { // not required
			return nil
		}

		if err := m.Commit.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit")
			}
			return err
		}
	}

	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) contextValidateHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.Header != nil {

		if swag.IsZero(m.Header) { // not required
			return nil
		}

		if err := m.Header.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) UnmarshalBinary(b []byte) error {
	var res TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit types block evidence evidence items0 light client attack evidence conflicting block signed header commit
//
// swagger:model TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit
type TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit struct {

	// block id
	BlockID *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID `json:"block_id,omitempty"`

	// height
	Height string `json:"height,omitempty"`

	// round
	Round int32 `json:"round,omitempty"`

	// signatures
	Signatures []*TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0 `json:"signatures"`
}

// Validate validates this types block evidence evidence items0 light client attack evidence conflicting block signed header commit
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSignatures(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) validateBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockID) { // not required
		return nil
	}

	if m.BlockID != nil {
		if err := m.BlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) validateSignatures(formats strfmt.Registry) error {
	if swag.IsZero(m.Signatures) { // not required
		return nil
	}

	for i := 0; i < len(m.Signatures); i++ {
		if swag.IsZero(m.Signatures[i]) { // not required
			continue
		}

		if m.Signatures[i] != nil {
			if err := m.Signatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "signatures" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "signatures" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this types block evidence evidence items0 light client attack evidence conflicting block signed header commit based on the context it is used
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSignatures(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) contextValidateBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.BlockID != nil {

		if swag.IsZero(m.BlockID) { // not required
			return nil
		}

		if err := m.BlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) contextValidateSignatures(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Signatures); i++ {

		if m.Signatures[i] != nil {

			if swag.IsZero(m.Signatures[i]) { // not required
				return nil
			}

			if err := m.Signatures[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "signatures" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "signatures" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) UnmarshalBinary(b []byte) error {
	var res TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID types block evidence evidence items0 light client attack evidence conflicting block signed header commit block ID
//
// swagger:model TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID
type TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this types block evidence evidence items0 light client attack evidence conflicting block signed header commit block ID
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this types block evidence evidence items0 light client attack evidence conflicting block signed header commit block ID based on the context it is used
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {

		if swag.IsZero(m.PartSetHeader) { // not required
			return nil
		}

		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID) UnmarshalBinary(b []byte) error {
	var res TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader types block evidence evidence items0 light client attack evidence conflicting block signed header commit block ID part set header
//
// swagger:model TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader
type TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this types block evidence evidence items0 light client attack evidence conflicting block signed header commit block ID part set header
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this types block evidence evidence items0 light client attack evidence conflicting block signed header commit block ID part set header based on context it is used
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0 types block evidence evidence items0 light client attack evidence conflicting block signed header commit signatures items0
//
// swagger:model TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0
type TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0 struct {

	// block id flag
	// Enum: ["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"]
	BlockIDFlag *string `json:"block_id_flag,omitempty"`

	// signature
	// Format: byte
	Signature strfmt.Base64 `json:"signature,omitempty"`

	// timestamp
	// Format: date-time
	Timestamp strfmt.DateTime `json:"timestamp,omitempty"`

	// validator address
	// Format: byte
	ValidatorAddress strfmt.Base64 `json:"validator_address,omitempty"`
}

// Validate validates this types block evidence evidence items0 light client attack evidence conflicting block signed header commit signatures items0
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockIDFlag(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var typesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0TypeBlockIDFlagPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		typesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0TypeBlockIDFlagPropEnum = append(typesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0TypeBlockIDFlagPropEnum, v)
	}
}

const (

	// TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGUNKNOWN captures enum value "BLOCK_ID_FLAG_UNKNOWN"
	TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGUNKNOWN string = "BLOCK_ID_FLAG_UNKNOWN"

	// TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGABSENT captures enum value "BLOCK_ID_FLAG_ABSENT"
	TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGABSENT string = "BLOCK_ID_FLAG_ABSENT"

	// TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGCOMMIT captures enum value "BLOCK_ID_FLAG_COMMIT"
	TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGCOMMIT string = "BLOCK_ID_FLAG_COMMIT"

	// TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGNIL captures enum value "BLOCK_ID_FLAG_NIL"
	TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGNIL string = "BLOCK_ID_FLAG_NIL"
)

// prop value enum
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) validateBlockIDFlagEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, typesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0TypeBlockIDFlagPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) validateBlockIDFlag(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockIDFlag) { // not required
		return nil
	}

	// value enum
	if err := m.validateBlockIDFlagEnum("block_id_flag", "body", *m.BlockIDFlag); err != nil {
		return err
	}

	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this types block evidence evidence items0 light client attack evidence conflicting block signed header commit signatures items0 based on context it is used
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) UnmarshalBinary(b []byte) error {
	var res TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader types block evidence evidence items0 light client attack evidence conflicting block signed header header
//
// swagger:model TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader
type TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader struct {

	// app hash
	// Format: byte
	AppHash strfmt.Base64 `json:"app_hash,omitempty"`

	// chain id
	ChainID string `json:"chain_id,omitempty"`

	// consensus hash
	// Format: byte
	ConsensusHash strfmt.Base64 `json:"consensus_hash,omitempty"`

	// data hash
	// Format: byte
	DataHash strfmt.Base64 `json:"data_hash,omitempty"`

	// evidence hash
	// Format: byte
	EvidenceHash strfmt.Base64 `json:"evidence_hash,omitempty"`

	// height
	Height string `json:"height,omitempty"`

	// last block id
	LastBlockID *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID `json:"last_block_id,omitempty"`

	// last commit hash
	// Format: byte
	LastCommitHash strfmt.Base64 `json:"last_commit_hash,omitempty"`

	// last results hash
	// Format: byte
	LastResultsHash strfmt.Base64 `json:"last_results_hash,omitempty"`

	// next validators hash
	// Format: byte
	NextValidatorsHash strfmt.Base64 `json:"next_validators_hash,omitempty"`

	// proposer address
	// Format: byte
	ProposerAddress strfmt.Base64 `json:"proposer_address,omitempty"`

	// time
	// Format: date-time
	Time strfmt.DateTime `json:"time,omitempty"`

	// validators hash
	// Format: byte
	ValidatorsHash strfmt.Base64 `json:"validators_hash,omitempty"`

	// version
	Version *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion `json:"version,omitempty"`
}

// Validate validates this types block evidence evidence items0 light client attack evidence conflicting block signed header header
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLastBlockID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) validateLastBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.LastBlockID) { // not required
		return nil
	}

	if m.LastBlockID != nil {
		if err := m.LastBlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id")
			}
			return err
		}
	}

	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) validateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.Time) { // not required
		return nil
	}

	if err := validate.FormatOf("light_client_attack_evidence"+"."+"conflicting_block"+"."+"signed_header"+"."+"header"+"."+"time", "body", "date-time", m.Time.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) validateVersion(formats strfmt.Registry) error {
	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if m.Version != nil {
		if err := m.Version.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "version")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "version")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this types block evidence evidence items0 light client attack evidence conflicting block signed header header based on the context it is used
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLastBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) contextValidateLastBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.LastBlockID != nil {

		if swag.IsZero(m.LastBlockID) { // not required
			return nil
		}

		if err := m.LastBlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id")
			}
			return err
		}
	}

	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) contextValidateVersion(ctx context.Context, formats strfmt.Registry) error {

	if m.Version != nil {

		if swag.IsZero(m.Version) { // not required
			return nil
		}

		if err := m.Version.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "version")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "version")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) UnmarshalBinary(b []byte) error {
	var res TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID types block evidence evidence items0 light client attack evidence conflicting block signed header header last block ID
//
// swagger:model TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID
type TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this types block evidence evidence items0 light client attack evidence conflicting block signed header header last block ID
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this types block evidence evidence items0 light client attack evidence conflicting block signed header header last block ID based on the context it is used
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {

		if swag.IsZero(m.PartSetHeader) { // not required
			return nil
		}

		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID) UnmarshalBinary(b []byte) error {
	var res TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader types block evidence evidence items0 light client attack evidence conflicting block signed header header last block ID part set header
//
// swagger:model TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader
type TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this types block evidence evidence items0 light client attack evidence conflicting block signed header header last block ID part set header
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this types block evidence evidence items0 light client attack evidence conflicting block signed header header last block ID part set header based on context it is used
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion types block evidence evidence items0 light client attack evidence conflicting block signed header header version
//
// swagger:model TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion
type TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion struct {

	// app
	App string `json:"app,omitempty"`

	// block
	Block string `json:"block,omitempty"`
}

// Validate validates this types block evidence evidence items0 light client attack evidence conflicting block signed header header version
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this types block evidence evidence items0 light client attack evidence conflicting block signed header header version based on context it is used
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion) UnmarshalBinary(b []byte) error {
	var res TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet types block evidence evidence items0 light client attack evidence conflicting block validator set
//
// swagger:model TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet
type TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet struct {

	// proposer
	Proposer *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer `json:"proposer,omitempty"`

	// total voting power
	TotalVotingPower string `json:"total_voting_power,omitempty"`

	// validators
	Validators []*TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0 `json:"validators"`
}

// Validate validates this types block evidence evidence items0 light client attack evidence conflicting block validator set
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateProposer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidators(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) validateProposer(formats strfmt.Registry) error {
	if swag.IsZero(m.Proposer) { // not required
		return nil
	}

	if m.Proposer != nil {
		if err := m.Proposer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer")
			}
			return err
		}
	}

	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) validateValidators(formats strfmt.Registry) error {
	if swag.IsZero(m.Validators) { // not required
		return nil
	}

	for i := 0; i < len(m.Validators); i++ {
		if swag.IsZero(m.Validators[i]) { // not required
			continue
		}

		if m.Validators[i] != nil {
			if err := m.Validators[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "validators" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "validators" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this types block evidence evidence items0 light client attack evidence conflicting block validator set based on the context it is used
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateProposer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateValidators(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) contextValidateProposer(ctx context.Context, formats strfmt.Registry) error {

	if m.Proposer != nil {

		if swag.IsZero(m.Proposer) { // not required
			return nil
		}

		if err := m.Proposer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer")
			}
			return err
		}
	}

	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) contextValidateValidators(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Validators); i++ {

		if m.Validators[i] != nil {

			if swag.IsZero(m.Validators[i]) { // not required
				return nil
			}

			if err := m.Validators[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "validators" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "validators" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) UnmarshalBinary(b []byte) error {
	var res TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer types block evidence evidence items0 light client attack evidence conflicting block validator set proposer
//
// swagger:model TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer
type TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer struct {

	// address
	// Format: byte
	Address strfmt.Base64 `json:"address,omitempty"`

	// proposer priority
	ProposerPriority string `json:"proposer_priority,omitempty"`

	// pub key
	PubKey *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey `json:"pub_key,omitempty"`

	// voting power
	VotingPower string `json:"voting_power,omitempty"`
}

// Validate validates this types block evidence evidence items0 light client attack evidence conflicting block validator set proposer
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePubKey(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer) validatePubKey(formats strfmt.Registry) error {
	if swag.IsZero(m.PubKey) { // not required
		return nil
	}

	if m.PubKey != nil {
		if err := m.PubKey.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer" + "." + "pub_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer" + "." + "pub_key")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this types block evidence evidence items0 light client attack evidence conflicting block validator set proposer based on the context it is used
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePubKey(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer) contextValidatePubKey(ctx context.Context, formats strfmt.Registry) error {

	if m.PubKey != nil {

		if swag.IsZero(m.PubKey) { // not required
			return nil
		}

		if err := m.PubKey.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer" + "." + "pub_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer" + "." + "pub_key")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer) UnmarshalBinary(b []byte) error {
	var res TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey types block evidence evidence items0 light client attack evidence conflicting block validator set proposer pub key
//
// swagger:model TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey
type TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey struct {

	// ed25519
	// Format: byte
	Ed25519 strfmt.Base64 `json:"ed25519,omitempty"`

	// secp256k1
	// Format: byte
	Secp256k1 strfmt.Base64 `json:"secp256k1,omitempty"`
}

// Validate validates this types block evidence evidence items0 light client attack evidence conflicting block validator set proposer pub key
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this types block evidence evidence items0 light client attack evidence conflicting block validator set proposer pub key based on context it is used
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey) UnmarshalBinary(b []byte) error {
	var res TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0 types block evidence evidence items0 light client attack evidence conflicting block validator set validators items0
//
// swagger:model TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0
type TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0 struct {

	// address
	// Format: byte
	Address strfmt.Base64 `json:"address,omitempty"`

	// proposer priority
	ProposerPriority string `json:"proposer_priority,omitempty"`

	// pub key
	PubKey *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey `json:"pub_key,omitempty"`

	// voting power
	VotingPower string `json:"voting_power,omitempty"`
}

// Validate validates this types block evidence evidence items0 light client attack evidence conflicting block validator set validators items0
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePubKey(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0) validatePubKey(formats strfmt.Registry) error {
	if swag.IsZero(m.PubKey) { // not required
		return nil
	}

	if m.PubKey != nil {
		if err := m.PubKey.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pub_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("pub_key")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this types block evidence evidence items0 light client attack evidence conflicting block validator set validators items0 based on the context it is used
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePubKey(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0) contextValidatePubKey(ctx context.Context, formats strfmt.Registry) error {

	if m.PubKey != nil {

		if swag.IsZero(m.PubKey) { // not required
			return nil
		}

		if err := m.PubKey.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pub_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("pub_key")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0) UnmarshalBinary(b []byte) error {
	var res TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey types block evidence evidence items0 light client attack evidence conflicting block validator set validators items0 pub key
//
// swagger:model TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey
type TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey struct {

	// ed25519
	// Format: byte
	Ed25519 strfmt.Base64 `json:"ed25519,omitempty"`

	// secp256k1
	// Format: byte
	Secp256k1 strfmt.Base64 `json:"secp256k1,omitempty"`
}

// Validate validates this types block evidence evidence items0 light client attack evidence conflicting block validator set validators items0 pub key
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this types block evidence evidence items0 light client attack evidence conflicting block validator set validators items0 pub key based on context it is used
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey) UnmarshalBinary(b []byte) error {
	var res TypesBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TypesBlockHeader types block header
//
// swagger:model TypesBlockHeader
type TypesBlockHeader struct {

	// app hash
	// Format: byte
	AppHash strfmt.Base64 `json:"app_hash,omitempty"`

	// chain id
	ChainID string `json:"chain_id,omitempty"`

	// consensus hash
	// Format: byte
	ConsensusHash strfmt.Base64 `json:"consensus_hash,omitempty"`

	// data hash
	// Format: byte
	DataHash strfmt.Base64 `json:"data_hash,omitempty"`

	// evidence hash
	// Format: byte
	EvidenceHash strfmt.Base64 `json:"evidence_hash,omitempty"`

	// height
	Height string `json:"height,omitempty"`

	// last block id
	LastBlockID *TypesBlockHeaderLastBlockID `json:"last_block_id,omitempty"`

	// last commit hash
	// Format: byte
	LastCommitHash strfmt.Base64 `json:"last_commit_hash,omitempty"`

	// last results hash
	// Format: byte
	LastResultsHash strfmt.Base64 `json:"last_results_hash,omitempty"`

	// next validators hash
	// Format: byte
	NextValidatorsHash strfmt.Base64 `json:"next_validators_hash,omitempty"`

	// proposer address
	// Format: byte
	ProposerAddress strfmt.Base64 `json:"proposer_address,omitempty"`

	// time
	// Format: date-time
	Time strfmt.DateTime `json:"time,omitempty"`

	// validators hash
	// Format: byte
	ValidatorsHash strfmt.Base64 `json:"validators_hash,omitempty"`

	// version
	Version *TypesBlockHeaderVersion `json:"version,omitempty"`
}

// Validate validates this types block header
func (m *TypesBlockHeader) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLastBlockID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockHeader) validateLastBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.LastBlockID) { // not required
		return nil
	}

	if m.LastBlockID != nil {
		if err := m.LastBlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("header" + "." + "last_block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("header" + "." + "last_block_id")
			}
			return err
		}
	}

	return nil
}

func (m *TypesBlockHeader) validateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.Time) { // not required
		return nil
	}

	if err := validate.FormatOf("header"+"."+"time", "body", "date-time", m.Time.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *TypesBlockHeader) validateVersion(formats strfmt.Registry) error {
	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if m.Version != nil {
		if err := m.Version.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("header" + "." + "version")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("header" + "." + "version")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this types block header based on the context it is used
func (m *TypesBlockHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLastBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockHeader) contextValidateLastBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.LastBlockID != nil {

		if swag.IsZero(m.LastBlockID) { // not required
			return nil
		}

		if err := m.LastBlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("header" + "." + "last_block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("header" + "." + "last_block_id")
			}
			return err
		}
	}

	return nil
}

func (m *TypesBlockHeader) contextValidateVersion(ctx context.Context, formats strfmt.Registry) error {

	if m.Version != nil {

		if swag.IsZero(m.Version) { // not required
			return nil
		}

		if err := m.Version.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("header" + "." + "version")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("header" + "." + "version")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlockHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlockHeader) UnmarshalBinary(b []byte) error {
	var res TypesBlockHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TypesBlockHeaderLastBlockID types block header last block ID
//
// swagger:model TypesBlockHeaderLastBlockID
type TypesBlockHeaderLastBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *TypesBlockHeaderLastBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this types block header last block ID
func (m *TypesBlockHeaderLastBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockHeaderLastBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("header" + "." + "last_block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("header" + "." + "last_block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this types block header last block ID based on the context it is used
func (m *TypesBlockHeaderLastBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockHeaderLastBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {

		if swag.IsZero(m.PartSetHeader) { // not required
			return nil
		}

		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("header" + "." + "last_block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("header" + "." + "last_block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlockHeaderLastBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlockHeaderLastBlockID) UnmarshalBinary(b []byte) error {
	var res TypesBlockHeaderLastBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TypesBlockHeaderLastBlockIDPartSetHeader types block header last block ID part set header
//
// swagger:model TypesBlockHeaderLastBlockIDPartSetHeader
type TypesBlockHeaderLastBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this types block header last block ID part set header
func (m *TypesBlockHeaderLastBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this types block header last block ID part set header based on context it is used
func (m *TypesBlockHeaderLastBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlockHeaderLastBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlockHeaderLastBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res TypesBlockHeaderLastBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TypesBlockHeaderVersion types block header version
//
// swagger:model TypesBlockHeaderVersion
type TypesBlockHeaderVersion struct {

	// app
	App string `json:"app,omitempty"`

	// block
	Block string `json:"block,omitempty"`
}

// Validate validates this types block header version
func (m *TypesBlockHeaderVersion) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this types block header version based on context it is used
func (m *TypesBlockHeaderVersion) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlockHeaderVersion) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlockHeaderVersion) UnmarshalBinary(b []byte) error {
	var res TypesBlockHeaderVersion
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TypesBlockLastCommit types block last commit
//
// swagger:model TypesBlockLastCommit
type TypesBlockLastCommit struct {

	// block id
	BlockID *TypesBlockLastCommitBlockID `json:"block_id,omitempty"`

	// height
	Height string `json:"height,omitempty"`

	// round
	Round int32 `json:"round,omitempty"`

	// signatures
	Signatures []*TypesBlockLastCommitSignaturesItems0 `json:"signatures"`
}

// Validate validates this types block last commit
func (m *TypesBlockLastCommit) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSignatures(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockLastCommit) validateBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockID) { // not required
		return nil
	}

	if m.BlockID != nil {
		if err := m.BlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("last_commit" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("last_commit" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

func (m *TypesBlockLastCommit) validateSignatures(formats strfmt.Registry) error {
	if swag.IsZero(m.Signatures) { // not required
		return nil
	}

	for i := 0; i < len(m.Signatures); i++ {
		if swag.IsZero(m.Signatures[i]) { // not required
			continue
		}

		if m.Signatures[i] != nil {
			if err := m.Signatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("last_commit" + "." + "signatures" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("last_commit" + "." + "signatures" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this types block last commit based on the context it is used
func (m *TypesBlockLastCommit) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSignatures(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockLastCommit) contextValidateBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.BlockID != nil {

		if swag.IsZero(m.BlockID) { // not required
			return nil
		}

		if err := m.BlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("last_commit" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("last_commit" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

func (m *TypesBlockLastCommit) contextValidateSignatures(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Signatures); i++ {

		if m.Signatures[i] != nil {

			if swag.IsZero(m.Signatures[i]) { // not required
				return nil
			}

			if err := m.Signatures[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("last_commit" + "." + "signatures" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("last_commit" + "." + "signatures" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlockLastCommit) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlockLastCommit) UnmarshalBinary(b []byte) error {
	var res TypesBlockLastCommit
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TypesBlockLastCommitBlockID types block last commit block ID
//
// swagger:model TypesBlockLastCommitBlockID
type TypesBlockLastCommitBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *TypesBlockLastCommitBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this types block last commit block ID
func (m *TypesBlockLastCommitBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockLastCommitBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("last_commit" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("last_commit" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this types block last commit block ID based on the context it is used
func (m *TypesBlockLastCommitBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TypesBlockLastCommitBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {

		if swag.IsZero(m.PartSetHeader) { // not required
			return nil
		}

		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("last_commit" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("last_commit" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlockLastCommitBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlockLastCommitBlockID) UnmarshalBinary(b []byte) error {
	var res TypesBlockLastCommitBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TypesBlockLastCommitBlockIDPartSetHeader types block last commit block ID part set header
//
// swagger:model TypesBlockLastCommitBlockIDPartSetHeader
type TypesBlockLastCommitBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this types block last commit block ID part set header
func (m *TypesBlockLastCommitBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this types block last commit block ID part set header based on context it is used
func (m *TypesBlockLastCommitBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlockLastCommitBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlockLastCommitBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res TypesBlockLastCommitBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// TypesBlockLastCommitSignaturesItems0 types block last commit signatures items0
//
// swagger:model TypesBlockLastCommitSignaturesItems0
type TypesBlockLastCommitSignaturesItems0 struct {

	// block id flag
	// Enum: ["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"]
	BlockIDFlag *string `json:"block_id_flag,omitempty"`

	// signature
	// Format: byte
	Signature strfmt.Base64 `json:"signature,omitempty"`

	// timestamp
	// Format: date-time
	Timestamp strfmt.DateTime `json:"timestamp,omitempty"`

	// validator address
	// Format: byte
	ValidatorAddress strfmt.Base64 `json:"validator_address,omitempty"`
}

// Validate validates this types block last commit signatures items0
func (m *TypesBlockLastCommitSignaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockIDFlag(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var typesBlockLastCommitSignaturesItems0TypeBlockIDFlagPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		typesBlockLastCommitSignaturesItems0TypeBlockIDFlagPropEnum = append(typesBlockLastCommitSignaturesItems0TypeBlockIDFlagPropEnum, v)
	}
}

const (

	// TypesBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGUNKNOWN captures enum value "BLOCK_ID_FLAG_UNKNOWN"
	TypesBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGUNKNOWN string = "BLOCK_ID_FLAG_UNKNOWN"

	// TypesBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGABSENT captures enum value "BLOCK_ID_FLAG_ABSENT"
	TypesBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGABSENT string = "BLOCK_ID_FLAG_ABSENT"

	// TypesBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGCOMMIT captures enum value "BLOCK_ID_FLAG_COMMIT"
	TypesBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGCOMMIT string = "BLOCK_ID_FLAG_COMMIT"

	// TypesBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGNIL captures enum value "BLOCK_ID_FLAG_NIL"
	TypesBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGNIL string = "BLOCK_ID_FLAG_NIL"
)

// prop value enum
func (m *TypesBlockLastCommitSignaturesItems0) validateBlockIDFlagEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, typesBlockLastCommitSignaturesItems0TypeBlockIDFlagPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *TypesBlockLastCommitSignaturesItems0) validateBlockIDFlag(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockIDFlag) { // not required
		return nil
	}

	// value enum
	if err := m.validateBlockIDFlagEnum("block_id_flag", "body", *m.BlockIDFlag); err != nil {
		return err
	}

	return nil
}

func (m *TypesBlockLastCommitSignaturesItems0) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this types block last commit signatures items0 based on context it is used
func (m *TypesBlockLastCommitSignaturesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *TypesBlockLastCommitSignaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TypesBlockLastCommitSignaturesItems0) UnmarshalBinary(b []byte) error {
	var res TypesBlockLastCommitSignaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
