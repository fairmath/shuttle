// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// GetBlockWithTxsResponse get block with txs response
//
// swagger:model GetBlockWithTxsResponse
type GetBlockWithTxsResponse struct {

	// block
	Block *GetBlockWithTxsResponseBlock `json:"block,omitempty"`

	// block id
	BlockID *GetBlockWithTxsResponseBlockID `json:"block_id,omitempty"`

	// pagination
	Pagination *GetBlockWithTxsResponsePagination `json:"pagination,omitempty"`

	// txs
	Txs []*Tx `json:"txs"`
}

// Validate validates this get block with txs response
func (m *GetBlockWithTxsResponse) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlock(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateBlockID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePagination(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTxs(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponse) validateBlock(formats strfmt.Registry) error {
	if swag.IsZero(m.Block) { // not required
		return nil
	}

	if m.Block != nil {
		if err := m.Block.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block")
			}
			return err
		}
	}

	return nil
}

func (m *GetBlockWithTxsResponse) validateBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockID) { // not required
		return nil
	}

	if m.BlockID != nil {
		if err := m.BlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block_id")
			}
			return err
		}
	}

	return nil
}

func (m *GetBlockWithTxsResponse) validatePagination(formats strfmt.Registry) error {
	if swag.IsZero(m.Pagination) { // not required
		return nil
	}

	if m.Pagination != nil {
		if err := m.Pagination.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pagination")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("pagination")
			}
			return err
		}
	}

	return nil
}

func (m *GetBlockWithTxsResponse) validateTxs(formats strfmt.Registry) error {
	if swag.IsZero(m.Txs) { // not required
		return nil
	}

	for i := 0; i < len(m.Txs); i++ {
		if swag.IsZero(m.Txs[i]) { // not required
			continue
		}

		if m.Txs[i] != nil {
			if err := m.Txs[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("txs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("txs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this get block with txs response based on the context it is used
func (m *GetBlockWithTxsResponse) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBlock(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePagination(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateTxs(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponse) contextValidateBlock(ctx context.Context, formats strfmt.Registry) error {

	if m.Block != nil {

		if swag.IsZero(m.Block) { // not required
			return nil
		}

		if err := m.Block.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block")
			}
			return err
		}
	}

	return nil
}

func (m *GetBlockWithTxsResponse) contextValidateBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.BlockID != nil {

		if swag.IsZero(m.BlockID) { // not required
			return nil
		}

		if err := m.BlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block_id")
			}
			return err
		}
	}

	return nil
}

func (m *GetBlockWithTxsResponse) contextValidatePagination(ctx context.Context, formats strfmt.Registry) error {

	if m.Pagination != nil {

		if swag.IsZero(m.Pagination) { // not required
			return nil
		}

		if err := m.Pagination.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pagination")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("pagination")
			}
			return err
		}
	}

	return nil
}

func (m *GetBlockWithTxsResponse) contextValidateTxs(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Txs); i++ {

		if m.Txs[i] != nil {

			if swag.IsZero(m.Txs[i]) { // not required
				return nil
			}

			if err := m.Txs[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("txs" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("txs" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponse) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponse) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponse
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlock get block with txs response block
//
// swagger:model GetBlockWithTxsResponseBlock
type GetBlockWithTxsResponseBlock struct {

	// data
	Data *GetBlockWithTxsResponseBlockData `json:"data,omitempty"`

	// evidence
	Evidence *GetBlockWithTxsResponseBlockEvidence `json:"evidence,omitempty"`

	// header
	Header *GetBlockWithTxsResponseBlockHeader `json:"header,omitempty"`

	// last commit
	LastCommit *GetBlockWithTxsResponseBlockLastCommit `json:"last_commit,omitempty"`
}

// Validate validates this get block with txs response block
func (m *GetBlockWithTxsResponseBlock) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateData(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEvidence(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHeader(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLastCommit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlock) validateData(formats strfmt.Registry) error {
	if swag.IsZero(m.Data) { // not required
		return nil
	}

	if m.Data != nil {
		if err := m.Data.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "data")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "data")
			}
			return err
		}
	}

	return nil
}

func (m *GetBlockWithTxsResponseBlock) validateEvidence(formats strfmt.Registry) error {
	if swag.IsZero(m.Evidence) { // not required
		return nil
	}

	if m.Evidence != nil {
		if err := m.Evidence.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "evidence")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "evidence")
			}
			return err
		}
	}

	return nil
}

func (m *GetBlockWithTxsResponseBlock) validateHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.Header) { // not required
		return nil
	}

	if m.Header != nil {
		if err := m.Header.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "header")
			}
			return err
		}
	}

	return nil
}

func (m *GetBlockWithTxsResponseBlock) validateLastCommit(formats strfmt.Registry) error {
	if swag.IsZero(m.LastCommit) { // not required
		return nil
	}

	if m.LastCommit != nil {
		if err := m.LastCommit.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "last_commit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "last_commit")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get block with txs response block based on the context it is used
func (m *GetBlockWithTxsResponseBlock) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateData(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateEvidence(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLastCommit(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlock) contextValidateData(ctx context.Context, formats strfmt.Registry) error {

	if m.Data != nil {

		if swag.IsZero(m.Data) { // not required
			return nil
		}

		if err := m.Data.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "data")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "data")
			}
			return err
		}
	}

	return nil
}

func (m *GetBlockWithTxsResponseBlock) contextValidateEvidence(ctx context.Context, formats strfmt.Registry) error {

	if m.Evidence != nil {

		if swag.IsZero(m.Evidence) { // not required
			return nil
		}

		if err := m.Evidence.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "evidence")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "evidence")
			}
			return err
		}
	}

	return nil
}

func (m *GetBlockWithTxsResponseBlock) contextValidateHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.Header != nil {

		if swag.IsZero(m.Header) { // not required
			return nil
		}

		if err := m.Header.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "header")
			}
			return err
		}
	}

	return nil
}

func (m *GetBlockWithTxsResponseBlock) contextValidateLastCommit(ctx context.Context, formats strfmt.Registry) error {

	if m.LastCommit != nil {

		if swag.IsZero(m.LastCommit) { // not required
			return nil
		}

		if err := m.LastCommit.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "last_commit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "last_commit")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlock) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlock) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlock
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockData get block with txs response block data
//
// swagger:model GetBlockWithTxsResponseBlockData
type GetBlockWithTxsResponseBlockData struct {

	// txs
	Txs []strfmt.Base64 `json:"txs"`
}

// Validate validates this get block with txs response block data
func (m *GetBlockWithTxsResponseBlockData) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get block with txs response block data based on context it is used
func (m *GetBlockWithTxsResponseBlockData) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockData) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockData) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockData
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockEvidence get block with txs response block evidence
//
// swagger:model GetBlockWithTxsResponseBlockEvidence
type GetBlockWithTxsResponseBlockEvidence struct {

	// evidence
	Evidence []*GetBlockWithTxsResponseBlockEvidenceEvidenceItems0 `json:"evidence"`
}

// Validate validates this get block with txs response block evidence
func (m *GetBlockWithTxsResponseBlockEvidence) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEvidence(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidence) validateEvidence(formats strfmt.Registry) error {
	if swag.IsZero(m.Evidence) { // not required
		return nil
	}

	for i := 0; i < len(m.Evidence); i++ {
		if swag.IsZero(m.Evidence[i]) { // not required
			continue
		}

		if m.Evidence[i] != nil {
			if err := m.Evidence[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("block" + "." + "evidence" + "." + "evidence" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("block" + "." + "evidence" + "." + "evidence" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this get block with txs response block evidence based on the context it is used
func (m *GetBlockWithTxsResponseBlockEvidence) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateEvidence(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidence) contextValidateEvidence(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Evidence); i++ {

		if m.Evidence[i] != nil {

			if swag.IsZero(m.Evidence[i]) { // not required
				return nil
			}

			if err := m.Evidence[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("block" + "." + "evidence" + "." + "evidence" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("block" + "." + "evidence" + "." + "evidence" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidence) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidence) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockEvidence
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0 get block with txs response block evidence evidence items0
//
// swagger:model GetBlockWithTxsResponseBlockEvidenceEvidenceItems0
type GetBlockWithTxsResponseBlockEvidenceEvidenceItems0 struct {

	// duplicate vote evidence
	DuplicateVoteEvidence *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidence `json:"duplicate_vote_evidence,omitempty"`

	// light client attack evidence
	LightClientAttackEvidence *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidence `json:"light_client_attack_evidence,omitempty"`
}

// Validate validates this get block with txs response block evidence evidence items0
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDuplicateVoteEvidence(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLightClientAttackEvidence(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0) validateDuplicateVoteEvidence(formats strfmt.Registry) error {
	if swag.IsZero(m.DuplicateVoteEvidence) { // not required
		return nil
	}

	if m.DuplicateVoteEvidence != nil {
		if err := m.DuplicateVoteEvidence.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence")
			}
			return err
		}
	}

	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0) validateLightClientAttackEvidence(formats strfmt.Registry) error {
	if swag.IsZero(m.LightClientAttackEvidence) { // not required
		return nil
	}

	if m.LightClientAttackEvidence != nil {
		if err := m.LightClientAttackEvidence.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get block with txs response block evidence evidence items0 based on the context it is used
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateDuplicateVoteEvidence(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateLightClientAttackEvidence(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0) contextValidateDuplicateVoteEvidence(ctx context.Context, formats strfmt.Registry) error {

	if m.DuplicateVoteEvidence != nil {

		if swag.IsZero(m.DuplicateVoteEvidence) { // not required
			return nil
		}

		if err := m.DuplicateVoteEvidence.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence")
			}
			return err
		}
	}

	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0) contextValidateLightClientAttackEvidence(ctx context.Context, formats strfmt.Registry) error {

	if m.LightClientAttackEvidence != nil {

		if swag.IsZero(m.LightClientAttackEvidence) { // not required
			return nil
		}

		if err := m.LightClientAttackEvidence.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockEvidenceEvidenceItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidence get block with txs response block evidence evidence items0 duplicate vote evidence
//
// swagger:model GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidence
type GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidence struct {

	// timestamp
	// Format: date-time
	Timestamp strfmt.DateTime `json:"timestamp,omitempty"`

	// total voting power
	TotalVotingPower string `json:"total_voting_power,omitempty"`

	// validator power
	ValidatorPower string `json:"validator_power,omitempty"`

	// vote a
	Votea *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea `json:"vote_a,omitempty"`

	// vote b
	Voteb *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb `json:"vote_b,omitempty"`
}

// Validate validates this get block with txs response block evidence evidence items0 duplicate vote evidence
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidence) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVotea(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVoteb(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidence) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("duplicate_vote_evidence"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidence) validateVotea(formats strfmt.Registry) error {
	if swag.IsZero(m.Votea) { // not required
		return nil
	}

	if m.Votea != nil {
		if err := m.Votea.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_a")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_a")
			}
			return err
		}
	}

	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidence) validateVoteb(formats strfmt.Registry) error {
	if swag.IsZero(m.Voteb) { // not required
		return nil
	}

	if m.Voteb != nil {
		if err := m.Voteb.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_b")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_b")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get block with txs response block evidence evidence items0 duplicate vote evidence based on the context it is used
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidence) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateVotea(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVoteb(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidence) contextValidateVotea(ctx context.Context, formats strfmt.Registry) error {

	if m.Votea != nil {

		if swag.IsZero(m.Votea) { // not required
			return nil
		}

		if err := m.Votea.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_a")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_a")
			}
			return err
		}
	}

	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidence) contextValidateVoteb(ctx context.Context, formats strfmt.Registry) error {

	if m.Voteb != nil {

		if swag.IsZero(m.Voteb) { // not required
			return nil
		}

		if err := m.Voteb.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_b")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_b")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidence) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidence) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidence
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea get block with txs response block evidence evidence items0 duplicate vote evidence votea
//
// swagger:model GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea
type GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea struct {

	// block id
	BlockID *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID `json:"block_id,omitempty"`

	// extension
	// Format: byte
	Extension strfmt.Base64 `json:"extension,omitempty"`

	// extension signature
	// Format: byte
	ExtensionSignature strfmt.Base64 `json:"extension_signature,omitempty"`

	// height
	Height string `json:"height,omitempty"`

	// round
	Round int32 `json:"round,omitempty"`

	// signature
	// Format: byte
	Signature strfmt.Base64 `json:"signature,omitempty"`

	// timestamp
	// Format: date-time
	Timestamp strfmt.DateTime `json:"timestamp,omitempty"`

	// type
	// Enum: ["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"]
	Type *string `json:"type,omitempty"`

	// validator address
	// Format: byte
	ValidatorAddress strfmt.Base64 `json:"validator_address,omitempty"`

	// validator index
	ValidatorIndex int32 `json:"validator_index,omitempty"`
}

// Validate validates this get block with txs response block evidence evidence items0 duplicate vote evidence votea
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) validateBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockID) { // not required
		return nil
	}

	if m.BlockID != nil {
		if err := m.BlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("duplicate_vote_evidence"+"."+"vote_a"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

var getBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		getBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeTypePropEnum = append(getBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeTypePropEnum, v)
	}
}

const (

	// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEUNKNOWN captures enum value "SIGNED_MSG_TYPE_UNKNOWN"
	GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEUNKNOWN string = "SIGNED_MSG_TYPE_UNKNOWN"

	// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEPREVOTE captures enum value "SIGNED_MSG_TYPE_PREVOTE"
	GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEPREVOTE string = "SIGNED_MSG_TYPE_PREVOTE"

	// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEPRECOMMIT captures enum value "SIGNED_MSG_TYPE_PRECOMMIT"
	GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEPRECOMMIT string = "SIGNED_MSG_TYPE_PRECOMMIT"

	// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEPROPOSAL captures enum value "SIGNED_MSG_TYPE_PROPOSAL"
	GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeSIGNEDMSGTYPEPROPOSAL string = "SIGNED_MSG_TYPE_PROPOSAL"
)

// prop value enum
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, getBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("duplicate_vote_evidence"+"."+"vote_a"+"."+"type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this get block with txs response block evidence evidence items0 duplicate vote evidence votea based on the context it is used
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) contextValidateBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.BlockID != nil {

		if swag.IsZero(m.BlockID) { // not required
			return nil
		}

		if err := m.BlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotea
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID get block with txs response block evidence evidence items0 duplicate vote evidence votea block ID
//
// swagger:model GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID
type GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this get block with txs response block evidence evidence items0 duplicate vote evidence votea block ID
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get block with txs response block evidence evidence items0 duplicate vote evidence votea block ID based on the context it is used
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {

		if swag.IsZero(m.PartSetHeader) { // not required
			return nil
		}

		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_a" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader get block with txs response block evidence evidence items0 duplicate vote evidence votea block ID part set header
//
// swagger:model GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader
type GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this get block with txs response block evidence evidence items0 duplicate vote evidence votea block ID part set header
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get block with txs response block evidence evidence items0 duplicate vote evidence votea block ID part set header based on context it is used
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteaBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb get block with txs response block evidence evidence items0 duplicate vote evidence voteb
//
// swagger:model GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb
type GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb struct {

	// block id
	BlockID *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID `json:"block_id,omitempty"`

	// extension
	// Format: byte
	Extension strfmt.Base64 `json:"extension,omitempty"`

	// extension signature
	// Format: byte
	ExtensionSignature strfmt.Base64 `json:"extension_signature,omitempty"`

	// height
	Height string `json:"height,omitempty"`

	// round
	Round int32 `json:"round,omitempty"`

	// signature
	// Format: byte
	Signature strfmt.Base64 `json:"signature,omitempty"`

	// timestamp
	// Format: date-time
	Timestamp strfmt.DateTime `json:"timestamp,omitempty"`

	// type
	// Enum: ["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"]
	Type *string `json:"type,omitempty"`

	// validator address
	// Format: byte
	ValidatorAddress strfmt.Base64 `json:"validator_address,omitempty"`

	// validator index
	ValidatorIndex int32 `json:"validator_index,omitempty"`
}

// Validate validates this get block with txs response block evidence evidence items0 duplicate vote evidence voteb
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) validateBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockID) { // not required
		return nil
	}

	if m.BlockID != nil {
		if err := m.BlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("duplicate_vote_evidence"+"."+"vote_b"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

var getBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SIGNED_MSG_TYPE_UNKNOWN","SIGNED_MSG_TYPE_PREVOTE","SIGNED_MSG_TYPE_PRECOMMIT","SIGNED_MSG_TYPE_PROPOSAL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		getBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeTypePropEnum = append(getBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeTypePropEnum, v)
	}
}

const (

	// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEUNKNOWN captures enum value "SIGNED_MSG_TYPE_UNKNOWN"
	GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEUNKNOWN string = "SIGNED_MSG_TYPE_UNKNOWN"

	// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEPREVOTE captures enum value "SIGNED_MSG_TYPE_PREVOTE"
	GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEPREVOTE string = "SIGNED_MSG_TYPE_PREVOTE"

	// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEPRECOMMIT captures enum value "SIGNED_MSG_TYPE_PRECOMMIT"
	GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEPRECOMMIT string = "SIGNED_MSG_TYPE_PRECOMMIT"

	// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEPROPOSAL captures enum value "SIGNED_MSG_TYPE_PROPOSAL"
	GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeSIGNEDMSGTYPEPROPOSAL string = "SIGNED_MSG_TYPE_PROPOSAL"
)

// prop value enum
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, getBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) validateType(formats strfmt.Registry) error {
	if swag.IsZero(m.Type) { // not required
		return nil
	}

	// value enum
	if err := m.validateTypeEnum("duplicate_vote_evidence"+"."+"vote_b"+"."+"type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this get block with txs response block evidence evidence items0 duplicate vote evidence voteb based on the context it is used
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) contextValidateBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.BlockID != nil {

		if swag.IsZero(m.BlockID) { // not required
			return nil
		}

		if err := m.BlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVoteb
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID get block with txs response block evidence evidence items0 duplicate vote evidence voteb block ID
//
// swagger:model GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID
type GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this get block with txs response block evidence evidence items0 duplicate vote evidence voteb block ID
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get block with txs response block evidence evidence items0 duplicate vote evidence voteb block ID based on the context it is used
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {

		if swag.IsZero(m.PartSetHeader) { // not required
			return nil
		}

		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("duplicate_vote_evidence" + "." + "vote_b" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader get block with txs response block evidence evidence items0 duplicate vote evidence voteb block ID part set header
//
// swagger:model GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader
type GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this get block with txs response block evidence evidence items0 duplicate vote evidence voteb block ID part set header
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get block with txs response block evidence evidence items0 duplicate vote evidence voteb block ID part set header based on context it is used
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockEvidenceEvidenceItems0DuplicateVoteEvidenceVotebBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidence get block with txs response block evidence evidence items0 light client attack evidence
//
// swagger:model GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidence
type GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidence struct {

	// byzantine validators
	ByzantineValidators []*GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0 `json:"byzantine_validators"`

	// common height
	CommonHeight string `json:"common_height,omitempty"`

	// conflicting block
	ConflictingBlock *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock `json:"conflicting_block,omitempty"`

	// timestamp
	// Format: date-time
	Timestamp strfmt.DateTime `json:"timestamp,omitempty"`

	// total voting power
	TotalVotingPower string `json:"total_voting_power,omitempty"`
}

// Validate validates this get block with txs response block evidence evidence items0 light client attack evidence
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidence) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateByzantineValidators(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConflictingBlock(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidence) validateByzantineValidators(formats strfmt.Registry) error {
	if swag.IsZero(m.ByzantineValidators) { // not required
		return nil
	}

	for i := 0; i < len(m.ByzantineValidators); i++ {
		if swag.IsZero(m.ByzantineValidators[i]) { // not required
			continue
		}

		if m.ByzantineValidators[i] != nil {
			if err := m.ByzantineValidators[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("light_client_attack_evidence" + "." + "byzantine_validators" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("light_client_attack_evidence" + "." + "byzantine_validators" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidence) validateConflictingBlock(formats strfmt.Registry) error {
	if swag.IsZero(m.ConflictingBlock) { // not required
		return nil
	}

	if m.ConflictingBlock != nil {
		if err := m.ConflictingBlock.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block")
			}
			return err
		}
	}

	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidence) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("light_client_attack_evidence"+"."+"timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this get block with txs response block evidence evidence items0 light client attack evidence based on the context it is used
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidence) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateByzantineValidators(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConflictingBlock(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidence) contextValidateByzantineValidators(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ByzantineValidators); i++ {

		if m.ByzantineValidators[i] != nil {

			if swag.IsZero(m.ByzantineValidators[i]) { // not required
				return nil
			}

			if err := m.ByzantineValidators[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("light_client_attack_evidence" + "." + "byzantine_validators" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("light_client_attack_evidence" + "." + "byzantine_validators" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidence) contextValidateConflictingBlock(ctx context.Context, formats strfmt.Registry) error {

	if m.ConflictingBlock != nil {

		if swag.IsZero(m.ConflictingBlock) { // not required
			return nil
		}

		if err := m.ConflictingBlock.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidence) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidence) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidence
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0 get block with txs response block evidence evidence items0 light client attack evidence byzantine validators items0
//
// swagger:model GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0
type GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0 struct {

	// address
	// Format: byte
	Address strfmt.Base64 `json:"address,omitempty"`

	// proposer priority
	ProposerPriority string `json:"proposer_priority,omitempty"`

	// pub key
	PubKey *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey `json:"pub_key,omitempty"`

	// voting power
	VotingPower string `json:"voting_power,omitempty"`
}

// Validate validates this get block with txs response block evidence evidence items0 light client attack evidence byzantine validators items0
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePubKey(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0) validatePubKey(formats strfmt.Registry) error {
	if swag.IsZero(m.PubKey) { // not required
		return nil
	}

	if m.PubKey != nil {
		if err := m.PubKey.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pub_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("pub_key")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get block with txs response block evidence evidence items0 light client attack evidence byzantine validators items0 based on the context it is used
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePubKey(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0) contextValidatePubKey(ctx context.Context, formats strfmt.Registry) error {

	if m.PubKey != nil {

		if swag.IsZero(m.PubKey) { // not required
			return nil
		}

		if err := m.PubKey.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pub_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("pub_key")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey get block with txs response block evidence evidence items0 light client attack evidence byzantine validators items0 pub key
//
// swagger:model GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey
type GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey struct {

	// ed25519
	// Format: byte
	Ed25519 strfmt.Base64 `json:"ed25519,omitempty"`

	// secp256k1
	// Format: byte
	Secp256k1 strfmt.Base64 `json:"secp256k1,omitempty"`
}

// Validate validates this get block with txs response block evidence evidence items0 light client attack evidence byzantine validators items0 pub key
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get block with txs response block evidence evidence items0 light client attack evidence byzantine validators items0 pub key based on context it is used
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceByzantineValidatorsItems0PubKey
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock get block with txs response block evidence evidence items0 light client attack evidence conflicting block
//
// swagger:model GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock
type GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock struct {

	// signed header
	SignedHeader *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader `json:"signed_header,omitempty"`

	// validator set
	ValidatorSet *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet `json:"validator_set,omitempty"`
}

// Validate validates this get block with txs response block evidence evidence items0 light client attack evidence conflicting block
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateSignedHeader(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidatorSet(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) validateSignedHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.SignedHeader) { // not required
		return nil
	}

	if m.SignedHeader != nil {
		if err := m.SignedHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header")
			}
			return err
		}
	}

	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) validateValidatorSet(formats strfmt.Registry) error {
	if swag.IsZero(m.ValidatorSet) { // not required
		return nil
	}

	if m.ValidatorSet != nil {
		if err := m.ValidatorSet.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get block with txs response block evidence evidence items0 light client attack evidence conflicting block based on the context it is used
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateSignedHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateValidatorSet(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) contextValidateSignedHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.SignedHeader != nil {

		if swag.IsZero(m.SignedHeader) { // not required
			return nil
		}

		if err := m.SignedHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header")
			}
			return err
		}
	}

	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) contextValidateValidatorSet(ctx context.Context, formats strfmt.Registry) error {

	if m.ValidatorSet != nil {

		if swag.IsZero(m.ValidatorSet) { // not required
			return nil
		}

		if err := m.ValidatorSet.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlock
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader get block with txs response block evidence evidence items0 light client attack evidence conflicting block signed header
//
// swagger:model GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader
type GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader struct {

	// commit
	Commit *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit `json:"commit,omitempty"`

	// header
	Header *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader `json:"header,omitempty"`
}

// Validate validates this get block with txs response block evidence evidence items0 light client attack evidence conflicting block signed header
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCommit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) validateCommit(formats strfmt.Registry) error {
	if swag.IsZero(m.Commit) { // not required
		return nil
	}

	if m.Commit != nil {
		if err := m.Commit.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit")
			}
			return err
		}
	}

	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) validateHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.Header) { // not required
		return nil
	}

	if m.Header != nil {
		if err := m.Header.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get block with txs response block evidence evidence items0 light client attack evidence conflicting block signed header based on the context it is used
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCommit(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) contextValidateCommit(ctx context.Context, formats strfmt.Registry) error {

	if m.Commit != nil {

		if swag.IsZero(m.Commit) { // not required
			return nil
		}

		if err := m.Commit.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit")
			}
			return err
		}
	}

	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) contextValidateHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.Header != nil {

		if swag.IsZero(m.Header) { // not required
			return nil
		}

		if err := m.Header.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit get block with txs response block evidence evidence items0 light client attack evidence conflicting block signed header commit
//
// swagger:model GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit
type GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit struct {

	// block id
	BlockID *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID `json:"block_id,omitempty"`

	// height
	Height string `json:"height,omitempty"`

	// round
	Round int32 `json:"round,omitempty"`

	// signatures
	Signatures []*GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0 `json:"signatures"`
}

// Validate validates this get block with txs response block evidence evidence items0 light client attack evidence conflicting block signed header commit
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSignatures(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) validateBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockID) { // not required
		return nil
	}

	if m.BlockID != nil {
		if err := m.BlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) validateSignatures(formats strfmt.Registry) error {
	if swag.IsZero(m.Signatures) { // not required
		return nil
	}

	for i := 0; i < len(m.Signatures); i++ {
		if swag.IsZero(m.Signatures[i]) { // not required
			continue
		}

		if m.Signatures[i] != nil {
			if err := m.Signatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "signatures" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "signatures" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this get block with txs response block evidence evidence items0 light client attack evidence conflicting block signed header commit based on the context it is used
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSignatures(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) contextValidateBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.BlockID != nil {

		if swag.IsZero(m.BlockID) { // not required
			return nil
		}

		if err := m.BlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) contextValidateSignatures(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Signatures); i++ {

		if m.Signatures[i] != nil {

			if swag.IsZero(m.Signatures[i]) { // not required
				return nil
			}

			if err := m.Signatures[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "signatures" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "signatures" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommit
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID get block with txs response block evidence evidence items0 light client attack evidence conflicting block signed header commit block ID
//
// swagger:model GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID
type GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this get block with txs response block evidence evidence items0 light client attack evidence conflicting block signed header commit block ID
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get block with txs response block evidence evidence items0 light client attack evidence conflicting block signed header commit block ID based on the context it is used
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {

		if swag.IsZero(m.PartSetHeader) { // not required
			return nil
		}

		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "commit" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader get block with txs response block evidence evidence items0 light client attack evidence conflicting block signed header commit block ID part set header
//
// swagger:model GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader
type GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this get block with txs response block evidence evidence items0 light client attack evidence conflicting block signed header commit block ID part set header
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get block with txs response block evidence evidence items0 light client attack evidence conflicting block signed header commit block ID part set header based on context it is used
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0 get block with txs response block evidence evidence items0 light client attack evidence conflicting block signed header commit signatures items0
//
// swagger:model GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0
type GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0 struct {

	// block id flag
	// Enum: ["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"]
	BlockIDFlag *string `json:"block_id_flag,omitempty"`

	// signature
	// Format: byte
	Signature strfmt.Base64 `json:"signature,omitempty"`

	// timestamp
	// Format: date-time
	Timestamp strfmt.DateTime `json:"timestamp,omitempty"`

	// validator address
	// Format: byte
	ValidatorAddress strfmt.Base64 `json:"validator_address,omitempty"`
}

// Validate validates this get block with txs response block evidence evidence items0 light client attack evidence conflicting block signed header commit signatures items0
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockIDFlag(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var getBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0TypeBlockIDFlagPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		getBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0TypeBlockIDFlagPropEnum = append(getBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0TypeBlockIDFlagPropEnum, v)
	}
}

const (

	// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGUNKNOWN captures enum value "BLOCK_ID_FLAG_UNKNOWN"
	GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGUNKNOWN string = "BLOCK_ID_FLAG_UNKNOWN"

	// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGABSENT captures enum value "BLOCK_ID_FLAG_ABSENT"
	GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGABSENT string = "BLOCK_ID_FLAG_ABSENT"

	// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGCOMMIT captures enum value "BLOCK_ID_FLAG_COMMIT"
	GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGCOMMIT string = "BLOCK_ID_FLAG_COMMIT"

	// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGNIL captures enum value "BLOCK_ID_FLAG_NIL"
	GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGNIL string = "BLOCK_ID_FLAG_NIL"
)

// prop value enum
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) validateBlockIDFlagEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, getBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0TypeBlockIDFlagPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) validateBlockIDFlag(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockIDFlag) { // not required
		return nil
	}

	// value enum
	if err := m.validateBlockIDFlagEnum("block_id_flag", "body", *m.BlockIDFlag); err != nil {
		return err
	}

	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this get block with txs response block evidence evidence items0 light client attack evidence conflicting block signed header commit signatures items0 based on context it is used
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderCommitSignaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader get block with txs response block evidence evidence items0 light client attack evidence conflicting block signed header header
//
// swagger:model GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader
type GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader struct {

	// app hash
	// Format: byte
	AppHash strfmt.Base64 `json:"app_hash,omitempty"`

	// chain id
	ChainID string `json:"chain_id,omitempty"`

	// consensus hash
	// Format: byte
	ConsensusHash strfmt.Base64 `json:"consensus_hash,omitempty"`

	// data hash
	// Format: byte
	DataHash strfmt.Base64 `json:"data_hash,omitempty"`

	// evidence hash
	// Format: byte
	EvidenceHash strfmt.Base64 `json:"evidence_hash,omitempty"`

	// height
	Height string `json:"height,omitempty"`

	// last block id
	LastBlockID *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID `json:"last_block_id,omitempty"`

	// last commit hash
	// Format: byte
	LastCommitHash strfmt.Base64 `json:"last_commit_hash,omitempty"`

	// last results hash
	// Format: byte
	LastResultsHash strfmt.Base64 `json:"last_results_hash,omitempty"`

	// next validators hash
	// Format: byte
	NextValidatorsHash strfmt.Base64 `json:"next_validators_hash,omitempty"`

	// proposer address
	// Format: byte
	ProposerAddress strfmt.Base64 `json:"proposer_address,omitempty"`

	// time
	// Format: date-time
	Time strfmt.DateTime `json:"time,omitempty"`

	// validators hash
	// Format: byte
	ValidatorsHash strfmt.Base64 `json:"validators_hash,omitempty"`

	// version
	Version *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion `json:"version,omitempty"`
}

// Validate validates this get block with txs response block evidence evidence items0 light client attack evidence conflicting block signed header header
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLastBlockID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) validateLastBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.LastBlockID) { // not required
		return nil
	}

	if m.LastBlockID != nil {
		if err := m.LastBlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id")
			}
			return err
		}
	}

	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) validateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.Time) { // not required
		return nil
	}

	if err := validate.FormatOf("light_client_attack_evidence"+"."+"conflicting_block"+"."+"signed_header"+"."+"header"+"."+"time", "body", "date-time", m.Time.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) validateVersion(formats strfmt.Registry) error {
	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if m.Version != nil {
		if err := m.Version.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "version")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "version")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get block with txs response block evidence evidence items0 light client attack evidence conflicting block signed header header based on the context it is used
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLastBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) contextValidateLastBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.LastBlockID != nil {

		if swag.IsZero(m.LastBlockID) { // not required
			return nil
		}

		if err := m.LastBlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id")
			}
			return err
		}
	}

	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) contextValidateVersion(ctx context.Context, formats strfmt.Registry) error {

	if m.Version != nil {

		if swag.IsZero(m.Version) { // not required
			return nil
		}

		if err := m.Version.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "version")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "version")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID get block with txs response block evidence evidence items0 light client attack evidence conflicting block signed header header last block ID
//
// swagger:model GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID
type GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this get block with txs response block evidence evidence items0 light client attack evidence conflicting block signed header header last block ID
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get block with txs response block evidence evidence items0 light client attack evidence conflicting block signed header header last block ID based on the context it is used
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {

		if swag.IsZero(m.PartSetHeader) { // not required
			return nil
		}

		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "signed_header" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader get block with txs response block evidence evidence items0 light client attack evidence conflicting block signed header header last block ID part set header
//
// swagger:model GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader
type GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this get block with txs response block evidence evidence items0 light client attack evidence conflicting block signed header header last block ID part set header
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get block with txs response block evidence evidence items0 light client attack evidence conflicting block signed header header last block ID part set header based on context it is used
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderLastBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion get block with txs response block evidence evidence items0 light client attack evidence conflicting block signed header header version
//
// swagger:model GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion
type GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion struct {

	// app
	App string `json:"app,omitempty"`

	// block
	Block string `json:"block,omitempty"`
}

// Validate validates this get block with txs response block evidence evidence items0 light client attack evidence conflicting block signed header header version
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get block with txs response block evidence evidence items0 light client attack evidence conflicting block signed header header version based on context it is used
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockSignedHeaderHeaderVersion
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet get block with txs response block evidence evidence items0 light client attack evidence conflicting block validator set
//
// swagger:model GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet
type GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet struct {

	// proposer
	Proposer *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer `json:"proposer,omitempty"`

	// total voting power
	TotalVotingPower string `json:"total_voting_power,omitempty"`

	// validators
	Validators []*GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0 `json:"validators"`
}

// Validate validates this get block with txs response block evidence evidence items0 light client attack evidence conflicting block validator set
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateProposer(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValidators(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) validateProposer(formats strfmt.Registry) error {
	if swag.IsZero(m.Proposer) { // not required
		return nil
	}

	if m.Proposer != nil {
		if err := m.Proposer.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer")
			}
			return err
		}
	}

	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) validateValidators(formats strfmt.Registry) error {
	if swag.IsZero(m.Validators) { // not required
		return nil
	}

	for i := 0; i < len(m.Validators); i++ {
		if swag.IsZero(m.Validators[i]) { // not required
			continue
		}

		if m.Validators[i] != nil {
			if err := m.Validators[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "validators" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "validators" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this get block with txs response block evidence evidence items0 light client attack evidence conflicting block validator set based on the context it is used
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateProposer(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateValidators(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) contextValidateProposer(ctx context.Context, formats strfmt.Registry) error {

	if m.Proposer != nil {

		if swag.IsZero(m.Proposer) { // not required
			return nil
		}

		if err := m.Proposer.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer")
			}
			return err
		}
	}

	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) contextValidateValidators(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Validators); i++ {

		if m.Validators[i] != nil {

			if swag.IsZero(m.Validators[i]) { // not required
				return nil
			}

			if err := m.Validators[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "validators" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "validators" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSet
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer get block with txs response block evidence evidence items0 light client attack evidence conflicting block validator set proposer
//
// swagger:model GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer
type GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer struct {

	// address
	// Format: byte
	Address strfmt.Base64 `json:"address,omitempty"`

	// proposer priority
	ProposerPriority string `json:"proposer_priority,omitempty"`

	// pub key
	PubKey *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey `json:"pub_key,omitempty"`

	// voting power
	VotingPower string `json:"voting_power,omitempty"`
}

// Validate validates this get block with txs response block evidence evidence items0 light client attack evidence conflicting block validator set proposer
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePubKey(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer) validatePubKey(formats strfmt.Registry) error {
	if swag.IsZero(m.PubKey) { // not required
		return nil
	}

	if m.PubKey != nil {
		if err := m.PubKey.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer" + "." + "pub_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer" + "." + "pub_key")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get block with txs response block evidence evidence items0 light client attack evidence conflicting block validator set proposer based on the context it is used
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePubKey(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer) contextValidatePubKey(ctx context.Context, formats strfmt.Registry) error {

	if m.PubKey != nil {

		if swag.IsZero(m.PubKey) { // not required
			return nil
		}

		if err := m.PubKey.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer" + "." + "pub_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("light_client_attack_evidence" + "." + "conflicting_block" + "." + "validator_set" + "." + "proposer" + "." + "pub_key")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposer
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey get block with txs response block evidence evidence items0 light client attack evidence conflicting block validator set proposer pub key
//
// swagger:model GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey
type GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey struct {

	// ed25519
	// Format: byte
	Ed25519 strfmt.Base64 `json:"ed25519,omitempty"`

	// secp256k1
	// Format: byte
	Secp256k1 strfmt.Base64 `json:"secp256k1,omitempty"`
}

// Validate validates this get block with txs response block evidence evidence items0 light client attack evidence conflicting block validator set proposer pub key
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get block with txs response block evidence evidence items0 light client attack evidence conflicting block validator set proposer pub key based on context it is used
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetProposerPubKey
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0 get block with txs response block evidence evidence items0 light client attack evidence conflicting block validator set validators items0
//
// swagger:model GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0
type GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0 struct {

	// address
	// Format: byte
	Address strfmt.Base64 `json:"address,omitempty"`

	// proposer priority
	ProposerPriority string `json:"proposer_priority,omitempty"`

	// pub key
	PubKey *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey `json:"pub_key,omitempty"`

	// voting power
	VotingPower string `json:"voting_power,omitempty"`
}

// Validate validates this get block with txs response block evidence evidence items0 light client attack evidence conflicting block validator set validators items0
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePubKey(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0) validatePubKey(formats strfmt.Registry) error {
	if swag.IsZero(m.PubKey) { // not required
		return nil
	}

	if m.PubKey != nil {
		if err := m.PubKey.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pub_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("pub_key")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get block with txs response block evidence evidence items0 light client attack evidence conflicting block validator set validators items0 based on the context it is used
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePubKey(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0) contextValidatePubKey(ctx context.Context, formats strfmt.Registry) error {

	if m.PubKey != nil {

		if swag.IsZero(m.PubKey) { // not required
			return nil
		}

		if err := m.PubKey.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pub_key")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("pub_key")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey get block with txs response block evidence evidence items0 light client attack evidence conflicting block validator set validators items0 pub key
//
// swagger:model GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey
type GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey struct {

	// ed25519
	// Format: byte
	Ed25519 strfmt.Base64 `json:"ed25519,omitempty"`

	// secp256k1
	// Format: byte
	Secp256k1 strfmt.Base64 `json:"secp256k1,omitempty"`
}

// Validate validates this get block with txs response block evidence evidence items0 light client attack evidence conflicting block validator set validators items0 pub key
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get block with txs response block evidence evidence items0 light client attack evidence conflicting block validator set validators items0 pub key based on context it is used
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockEvidenceEvidenceItems0LightClientAttackEvidenceConflictingBlockValidatorSetValidatorsItems0PubKey
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockHeader get block with txs response block header
//
// swagger:model GetBlockWithTxsResponseBlockHeader
type GetBlockWithTxsResponseBlockHeader struct {

	// app hash
	// Format: byte
	AppHash strfmt.Base64 `json:"app_hash,omitempty"`

	// chain id
	ChainID string `json:"chain_id,omitempty"`

	// consensus hash
	// Format: byte
	ConsensusHash strfmt.Base64 `json:"consensus_hash,omitempty"`

	// data hash
	// Format: byte
	DataHash strfmt.Base64 `json:"data_hash,omitempty"`

	// evidence hash
	// Format: byte
	EvidenceHash strfmt.Base64 `json:"evidence_hash,omitempty"`

	// height
	Height string `json:"height,omitempty"`

	// last block id
	LastBlockID *GetBlockWithTxsResponseBlockHeaderLastBlockID `json:"last_block_id,omitempty"`

	// last commit hash
	// Format: byte
	LastCommitHash strfmt.Base64 `json:"last_commit_hash,omitempty"`

	// last results hash
	// Format: byte
	LastResultsHash strfmt.Base64 `json:"last_results_hash,omitempty"`

	// next validators hash
	// Format: byte
	NextValidatorsHash strfmt.Base64 `json:"next_validators_hash,omitempty"`

	// proposer address
	// Format: byte
	ProposerAddress strfmt.Base64 `json:"proposer_address,omitempty"`

	// time
	// Format: date-time
	Time strfmt.DateTime `json:"time,omitempty"`

	// validators hash
	// Format: byte
	ValidatorsHash strfmt.Base64 `json:"validators_hash,omitempty"`

	// version
	Version *GetBlockWithTxsResponseBlockHeaderVersion `json:"version,omitempty"`
}

// Validate validates this get block with txs response block header
func (m *GetBlockWithTxsResponseBlockHeader) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateLastBlockID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVersion(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockHeader) validateLastBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.LastBlockID) { // not required
		return nil
	}

	if m.LastBlockID != nil {
		if err := m.LastBlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "header" + "." + "last_block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "header" + "." + "last_block_id")
			}
			return err
		}
	}

	return nil
}

func (m *GetBlockWithTxsResponseBlockHeader) validateTime(formats strfmt.Registry) error {
	if swag.IsZero(m.Time) { // not required
		return nil
	}

	if err := validate.FormatOf("block"+"."+"header"+"."+"time", "body", "date-time", m.Time.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *GetBlockWithTxsResponseBlockHeader) validateVersion(formats strfmt.Registry) error {
	if swag.IsZero(m.Version) { // not required
		return nil
	}

	if m.Version != nil {
		if err := m.Version.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "header" + "." + "version")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "header" + "." + "version")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get block with txs response block header based on the context it is used
func (m *GetBlockWithTxsResponseBlockHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateLastBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVersion(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockHeader) contextValidateLastBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.LastBlockID != nil {

		if swag.IsZero(m.LastBlockID) { // not required
			return nil
		}

		if err := m.LastBlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "header" + "." + "last_block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "header" + "." + "last_block_id")
			}
			return err
		}
	}

	return nil
}

func (m *GetBlockWithTxsResponseBlockHeader) contextValidateVersion(ctx context.Context, formats strfmt.Registry) error {

	if m.Version != nil {

		if swag.IsZero(m.Version) { // not required
			return nil
		}

		if err := m.Version.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "header" + "." + "version")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "header" + "." + "version")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockHeader) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockHeaderLastBlockID get block with txs response block header last block ID
//
// swagger:model GetBlockWithTxsResponseBlockHeaderLastBlockID
type GetBlockWithTxsResponseBlockHeaderLastBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *GetBlockWithTxsResponseBlockHeaderLastBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this get block with txs response block header last block ID
func (m *GetBlockWithTxsResponseBlockHeaderLastBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockHeaderLastBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get block with txs response block header last block ID based on the context it is used
func (m *GetBlockWithTxsResponseBlockHeaderLastBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockHeaderLastBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {

		if swag.IsZero(m.PartSetHeader) { // not required
			return nil
		}

		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "header" + "." + "last_block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockHeaderLastBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockHeaderLastBlockID) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockHeaderLastBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockHeaderLastBlockIDPartSetHeader get block with txs response block header last block ID part set header
//
// swagger:model GetBlockWithTxsResponseBlockHeaderLastBlockIDPartSetHeader
type GetBlockWithTxsResponseBlockHeaderLastBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this get block with txs response block header last block ID part set header
func (m *GetBlockWithTxsResponseBlockHeaderLastBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get block with txs response block header last block ID part set header based on context it is used
func (m *GetBlockWithTxsResponseBlockHeaderLastBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockHeaderLastBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockHeaderLastBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockHeaderLastBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockHeaderVersion get block with txs response block header version
//
// swagger:model GetBlockWithTxsResponseBlockHeaderVersion
type GetBlockWithTxsResponseBlockHeaderVersion struct {

	// app
	App string `json:"app,omitempty"`

	// block
	Block string `json:"block,omitempty"`
}

// Validate validates this get block with txs response block header version
func (m *GetBlockWithTxsResponseBlockHeaderVersion) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get block with txs response block header version based on context it is used
func (m *GetBlockWithTxsResponseBlockHeaderVersion) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockHeaderVersion) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockHeaderVersion) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockHeaderVersion
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockID get block with txs response block ID
//
// swagger:model GetBlockWithTxsResponseBlockID
type GetBlockWithTxsResponseBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *GetBlockWithTxsResponseBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this get block with txs response block ID
func (m *GetBlockWithTxsResponseBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get block with txs response block ID based on the context it is used
func (m *GetBlockWithTxsResponseBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {

		if swag.IsZero(m.PartSetHeader) { // not required
			return nil
		}

		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockID) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockIDPartSetHeader get block with txs response block ID part set header
//
// swagger:model GetBlockWithTxsResponseBlockIDPartSetHeader
type GetBlockWithTxsResponseBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this get block with txs response block ID part set header
func (m *GetBlockWithTxsResponseBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get block with txs response block ID part set header based on context it is used
func (m *GetBlockWithTxsResponseBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockLastCommit get block with txs response block last commit
//
// swagger:model GetBlockWithTxsResponseBlockLastCommit
type GetBlockWithTxsResponseBlockLastCommit struct {

	// block id
	BlockID *GetBlockWithTxsResponseBlockLastCommitBlockID `json:"block_id,omitempty"`

	// height
	Height string `json:"height,omitempty"`

	// round
	Round int32 `json:"round,omitempty"`

	// signatures
	Signatures []*GetBlockWithTxsResponseBlockLastCommitSignaturesItems0 `json:"signatures"`
}

// Validate validates this get block with txs response block last commit
func (m *GetBlockWithTxsResponseBlockLastCommit) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSignatures(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockLastCommit) validateBlockID(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockID) { // not required
		return nil
	}

	if m.BlockID != nil {
		if err := m.BlockID.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "last_commit" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "last_commit" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

func (m *GetBlockWithTxsResponseBlockLastCommit) validateSignatures(formats strfmt.Registry) error {
	if swag.IsZero(m.Signatures) { // not required
		return nil
	}

	for i := 0; i < len(m.Signatures); i++ {
		if swag.IsZero(m.Signatures[i]) { // not required
			continue
		}

		if m.Signatures[i] != nil {
			if err := m.Signatures[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("block" + "." + "last_commit" + "." + "signatures" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("block" + "." + "last_commit" + "." + "signatures" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// ContextValidate validate this get block with txs response block last commit based on the context it is used
func (m *GetBlockWithTxsResponseBlockLastCommit) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBlockID(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateSignatures(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockLastCommit) contextValidateBlockID(ctx context.Context, formats strfmt.Registry) error {

	if m.BlockID != nil {

		if swag.IsZero(m.BlockID) { // not required
			return nil
		}

		if err := m.BlockID.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "last_commit" + "." + "block_id")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "last_commit" + "." + "block_id")
			}
			return err
		}
	}

	return nil
}

func (m *GetBlockWithTxsResponseBlockLastCommit) contextValidateSignatures(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.Signatures); i++ {

		if m.Signatures[i] != nil {

			if swag.IsZero(m.Signatures[i]) { // not required
				return nil
			}

			if err := m.Signatures[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("block" + "." + "last_commit" + "." + "signatures" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("block" + "." + "last_commit" + "." + "signatures" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockLastCommit) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockLastCommit) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockLastCommit
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockLastCommitBlockID get block with txs response block last commit block ID
//
// swagger:model GetBlockWithTxsResponseBlockLastCommitBlockID
type GetBlockWithTxsResponseBlockLastCommitBlockID struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// part set header
	PartSetHeader *GetBlockWithTxsResponseBlockLastCommitBlockIDPartSetHeader `json:"part_set_header,omitempty"`
}

// Validate validates this get block with txs response block last commit block ID
func (m *GetBlockWithTxsResponseBlockLastCommitBlockID) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validatePartSetHeader(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockLastCommitBlockID) validatePartSetHeader(formats strfmt.Registry) error {
	if swag.IsZero(m.PartSetHeader) { // not required
		return nil
	}

	if m.PartSetHeader != nil {
		if err := m.PartSetHeader.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "last_commit" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "last_commit" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this get block with txs response block last commit block ID based on the context it is used
func (m *GetBlockWithTxsResponseBlockLastCommitBlockID) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidatePartSetHeader(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockLastCommitBlockID) contextValidatePartSetHeader(ctx context.Context, formats strfmt.Registry) error {

	if m.PartSetHeader != nil {

		if swag.IsZero(m.PartSetHeader) { // not required
			return nil
		}

		if err := m.PartSetHeader.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("block" + "." + "last_commit" + "." + "block_id" + "." + "part_set_header")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("block" + "." + "last_commit" + "." + "block_id" + "." + "part_set_header")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockLastCommitBlockID) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockLastCommitBlockID) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockLastCommitBlockID
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockLastCommitBlockIDPartSetHeader get block with txs response block last commit block ID part set header
//
// swagger:model GetBlockWithTxsResponseBlockLastCommitBlockIDPartSetHeader
type GetBlockWithTxsResponseBlockLastCommitBlockIDPartSetHeader struct {

	// hash
	// Format: byte
	Hash strfmt.Base64 `json:"hash,omitempty"`

	// total
	Total int64 `json:"total,omitempty"`
}

// Validate validates this get block with txs response block last commit block ID part set header
func (m *GetBlockWithTxsResponseBlockLastCommitBlockIDPartSetHeader) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get block with txs response block last commit block ID part set header based on context it is used
func (m *GetBlockWithTxsResponseBlockLastCommitBlockIDPartSetHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockLastCommitBlockIDPartSetHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockLastCommitBlockIDPartSetHeader) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockLastCommitBlockIDPartSetHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponseBlockLastCommitSignaturesItems0 get block with txs response block last commit signatures items0
//
// swagger:model GetBlockWithTxsResponseBlockLastCommitSignaturesItems0
type GetBlockWithTxsResponseBlockLastCommitSignaturesItems0 struct {

	// block id flag
	// Enum: ["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"]
	BlockIDFlag *string `json:"block_id_flag,omitempty"`

	// signature
	// Format: byte
	Signature strfmt.Base64 `json:"signature,omitempty"`

	// timestamp
	// Format: date-time
	Timestamp strfmt.DateTime `json:"timestamp,omitempty"`

	// validator address
	// Format: byte
	ValidatorAddress strfmt.Base64 `json:"validator_address,omitempty"`
}

// Validate validates this get block with txs response block last commit signatures items0
func (m *GetBlockWithTxsResponseBlockLastCommitSignaturesItems0) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBlockIDFlag(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTimestamp(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var getBlockWithTxsResponseBlockLastCommitSignaturesItems0TypeBlockIDFlagPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["BLOCK_ID_FLAG_UNKNOWN","BLOCK_ID_FLAG_ABSENT","BLOCK_ID_FLAG_COMMIT","BLOCK_ID_FLAG_NIL"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		getBlockWithTxsResponseBlockLastCommitSignaturesItems0TypeBlockIDFlagPropEnum = append(getBlockWithTxsResponseBlockLastCommitSignaturesItems0TypeBlockIDFlagPropEnum, v)
	}
}

const (

	// GetBlockWithTxsResponseBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGUNKNOWN captures enum value "BLOCK_ID_FLAG_UNKNOWN"
	GetBlockWithTxsResponseBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGUNKNOWN string = "BLOCK_ID_FLAG_UNKNOWN"

	// GetBlockWithTxsResponseBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGABSENT captures enum value "BLOCK_ID_FLAG_ABSENT"
	GetBlockWithTxsResponseBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGABSENT string = "BLOCK_ID_FLAG_ABSENT"

	// GetBlockWithTxsResponseBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGCOMMIT captures enum value "BLOCK_ID_FLAG_COMMIT"
	GetBlockWithTxsResponseBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGCOMMIT string = "BLOCK_ID_FLAG_COMMIT"

	// GetBlockWithTxsResponseBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGNIL captures enum value "BLOCK_ID_FLAG_NIL"
	GetBlockWithTxsResponseBlockLastCommitSignaturesItems0BlockIDFlagBLOCKIDFLAGNIL string = "BLOCK_ID_FLAG_NIL"
)

// prop value enum
func (m *GetBlockWithTxsResponseBlockLastCommitSignaturesItems0) validateBlockIDFlagEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, getBlockWithTxsResponseBlockLastCommitSignaturesItems0TypeBlockIDFlagPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *GetBlockWithTxsResponseBlockLastCommitSignaturesItems0) validateBlockIDFlag(formats strfmt.Registry) error {
	if swag.IsZero(m.BlockIDFlag) { // not required
		return nil
	}

	// value enum
	if err := m.validateBlockIDFlagEnum("block_id_flag", "body", *m.BlockIDFlag); err != nil {
		return err
	}

	return nil
}

func (m *GetBlockWithTxsResponseBlockLastCommitSignaturesItems0) validateTimestamp(formats strfmt.Registry) error {
	if swag.IsZero(m.Timestamp) { // not required
		return nil
	}

	if err := validate.FormatOf("timestamp", "body", "date-time", m.Timestamp.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this get block with txs response block last commit signatures items0 based on context it is used
func (m *GetBlockWithTxsResponseBlockLastCommitSignaturesItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockLastCommitSignaturesItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponseBlockLastCommitSignaturesItems0) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponseBlockLastCommitSignaturesItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// GetBlockWithTxsResponsePagination get block with txs response pagination
//
// swagger:model GetBlockWithTxsResponsePagination
type GetBlockWithTxsResponsePagination struct {

	// next key
	// Format: byte
	NextKey strfmt.Base64 `json:"next_key,omitempty"`

	// total
	Total string `json:"total,omitempty"`
}

// Validate validates this get block with txs response pagination
func (m *GetBlockWithTxsResponsePagination) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this get block with txs response pagination based on context it is used
func (m *GetBlockWithTxsResponsePagination) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *GetBlockWithTxsResponsePagination) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GetBlockWithTxsResponsePagination) UnmarshalBinary(b []byte) error {
	var res GetBlockWithTxsResponsePagination
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
